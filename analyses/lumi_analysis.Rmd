
---
title: "Pre-reaching infants expect causal agents to reach efficiently"
author: "Shari Liu"
date: "July 31 2018"
output: html_document
---

# Tables and Figures

**Table 1.** Summary of conditions, design, and sample sizes of Experiments 1-5, and Skerry et al (2013) (SCS) Experiments 1-5, including sample size (N), what motor training procedures were used (effective sticky mittens, ineffective non-sticky mittens, or none), the goal of the person reaching (changing an object’s state, or picking it up), whether the person acted on the object in a spatiotemporally contingent manner (causal: yes, or no), and whether the person wore a mitten (yes or no). Conditions listed under a single experiment (e.g. Exp 1 and 3) included random assignment to condition. For stimuli, see Fig 1. * indicates direct replication. For stimuli, see Fig 1.

Experiment | N | Training |  Goal | Habituation | Causal | Mitten | Stimuli
---------- | - | ---------| ----- | ----------- | ------ | ------ | -------
1 | 20 | none | state change | constrained | yes | yes | H1, T1
1 | 20 | none | state change | unconstrained | yes | yes | H2, T1
2 | 20 | none | state change | constrained | no | yes | H3, T2
3* | 26 | none |  state change | constrained | yes | yes | H1, T1
3* | 26 | none | state change | constrained | no | yes | H3, T2
4 | 20 | none | pick up | constrained | yes | yes | H4, T3
5 | 20 | none | pick up | constrained | yes | no | H5, T4
SCS 1 | 20 | effective | pick up | constrained | yes | yes |
SCS 2 | 20 | ineffective | pick up | constrained | yes | yes |
SCS 3 | 20 | none | pick up | constrained | yes | yes |
SCS 4* | 26 | effective | pick up | constrained | yes | yes |
SCS 5 | 26 | effective | pick up |unconstrained | yes | yes |

***

![**Figure 1.** Still frames from videos shown to participants in Experiments 1-5, including stimuli from habituation (H1-H5) and test (T1-T4). In each video, a person reached for and caused a change in an object (H1-H3, T1-T2), or picked up the object (H4-H5, T3-T4), over a barrier (H1- H2, H4-H5) or over empty space (H2, T1-T4).  The person either acted on the object by contacting it (H1-H2, H4-H5, T1, T3-T4) or produced the same effect from a distance of 50 pixels, after a 0.5s delay (H3, T2), and either performed these actions while wearing a mitten (H1-H4, T1-T3) or with a bare hand (H5, T4) During test (T1-T4), the person either reached directly for the object on a novel but efficient trajectory (T1-T4, left panel), or in a curvilinear fashion on the familiar but inefficient trajectory (T1-T4, right panel).](/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/fig1.jpeg)

***

```{r setup, include = FALSE}
knitr::opts_chunk$set(comment = "##", echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE, include=FALSE, dependson="lumi_wide")
options(scipen = 0, digits = 3)
## load required packages
ipak <- function (pkg) {
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# Install devtools package if necessary
if(!"devtools" %in% rownames(installed.packages())) install.packages("devtools")

# Install the stable development verions from GitHub
devtools::install_github("crsh/papaja")
devtools::install_github('achetverikov/apastats',subdir='apastats')

packages <- c("tidyverse", "Hmisc", "lattice", "multcomp", "lsmeans", "schoRsch", "influence.ME", "devtools", "skimr", "simr", "lme4", "sjPlot", "effects", "lmerTest", "compute.es", "pwr", "stringr", "irr", "papaja", "apastats")

ipak(packages)

```

```{r import}

lumi.wide <- read.csv("/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/lumi_data_deid.csv", header = TRUE) # change to your local directory
lumi.rel <- read.csv("/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/lumi_reliability.csv", header=TRUE)

str(lumi.wide)
```

```{r prep_data}
# convert to long format
lumi.long <- gather(lumi.wide, type, look, ineff.1:avg.eff)
str(lumi.long)
lumi.long$type <- factor(lumi.long$type)
lumi.long$loglook <- log(lumi.long$look)
lumi.long$testpair <- NA
lumi.long$testtype <- NA

# assign test pair and type info to data from individual test trials
for (i in 1:nrow(lumi.long)) {
  if (lumi.long$type[i] == "ineff.1" | lumi.long$type[i] == "prop.ineff1") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "ineff.2" | lumi.long$type[i] == "prop.ineff2") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "ineff.3" | lumi.long$type[i] == "prop.ineff3") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "third"
  }
  else if (lumi.long$type[i] == "eff.1") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "eff.2") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "eff.3") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "third"
  }
}


# set baseline levels of all categorical predictors for analyses later on
lumi.long$testtype <- factor(lumi.long$testtype)
lumi.long$testtype <- relevel(lumi.long$testtype, ref = "inefficient")
lumi.long$testpair <- factor(lumi.long$testpair)
lumi.long$testpair <- relevel(lumi.long$testpair, ref = "first")
lumi.wide$first.test <- relevel(lumi.wide$first.test, ref = "efficient")
lumi.wide$goal <- relevel(lumi.wide$goal, ref = "pick.up")
lumi.wide$hab <- relevel(lumi.wide$hab, ref = "unconstrained")
lumi.wide$mitten <- relevel(lumi.wide$mitten, ref = "no.mitten")
lumi.wide$training <- relevel(lumi.wide$training, ref = "no.training")
lumi.wide$causal <- relevel(lumi.wide$causal, ref = "no.causal")
lumi.wide$sex <- relevel(lumi.wide$sex, ref = "m")
lumi.wide$habbed <- factor(lumi.wide$habbed)
lumi.wide$habbed <- relevel(lumi.wide$habbed, ref = "0")
lumi.wide$pref <- relevel(lumi.wide$pref, ref = "eff")

# section data based on dv
lumi.prop.avg <- filter(lumi.long, type == "prop.ineff.all")
lumi.raw.avg <- filter(lumi.long, type == "avg.eff" | type == "avg.ineff")
lumi.raw.avg$type <- relevel(lumi.raw.avg$type, ref = "avg.ineff")
lumi.prop.tp <- filter(lumi.long, type == "prop.ineff1" | type == "prop.ineff2" | type == "prop.ineff3")
lumi.raw.tp <- filter(lumi.long, type == "ineff.1" | type == "ineff.2" | type == "ineff.3" | type == "eff.1" |type == "eff.2"| type == "eff.3")
```


```{r within_variance}
## Retrieved from : http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#error-bars-for-within-subjects-variables
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the "mean" column    
  datac <- plyr::rename(datac, c("mean" = measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}
## Norms the data within specified groups in a data frame; it normalizes each
## subject (identified by idvar) so that they have the same mean, within each group
## specified by betweenvars.
##   data: a data frame.
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   na.rm: a boolean that indicates whether to ignore NA's
normDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
  library(plyr)
  
  # Measure var on left, idvar + between vars on right of formula.
  data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,
                         .fun = function(xx, col, na.rm) {
                           c(subjMean = mean(xx[,col], na.rm=na.rm))
                         },
                         measurevar,
                         na.rm
  )
  
  # Put the subject means with original data
  data <- merge(data, data.subjMean)
  
  # Get the normalized data in a new column
  measureNormedVar <- paste(measurevar, "_norm", sep="")
  data[,measureNormedVar] <- data[,measurevar] - data[,"subjMean"] +
    mean(data[,measurevar], na.rm=na.rm)
  
  # Remove this subject mean column
  data$subjMean <- NULL
  
  return(data)
}

## Summarizes data, handling within-subjects variables by removing inter-subject variability.
## It will still work if there are no within-S variables.
## Gives count, un-normed mean, normed mean (with same between-group mean),
##   standard deviation, standard error of the mean, and confidence interval.
## If there are within-subject variables, calculate adjusted values using method from Morey (2008).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   withinvars: a vector containing names of columns that are within-subjects variables
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,
                            idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
  
  # Ensure that the betweenvars and withinvars are factors
  factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                       FUN=is.factor, FUN.VALUE=logical(1))
  
  if (!all(factorvars)) {
    nonfactorvars <- names(factorvars)[!factorvars]
    message("Automatically converting the following non-factors to factors: ",
            paste(nonfactorvars, collapse = ", "))
    data[nonfactorvars] <- lapply(data[nonfactorvars], factor)
  }
  
  # Get the means from the un-normed data
  datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                     na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Drop all the unused columns (these will be calculated with normed data)
  datac$sd <- NULL
  datac$se <- NULL
  datac$ci <- NULL
  
  # Norm each subject's data
  ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
  
  # This is the name of the new column
  measurevar_n <- paste(measurevar, "_norm", sep="")
  
  # Collapse the normed data - now we can treat between and within vars the same
  ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                      na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Apply correction from Morey (2008) to the standard error and confidence interval
  #  Get the product of the number of conditions of within-S variables
  nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                  FUN.VALUE=numeric(1)))
  correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )
  
  # Apply the correction factor
  ndatac$sd <- ndatac$sd * correctionFactor
  ndatac$se <- ndatac$se * correctionFactor
  ndatac$ci <- ndatac$ci * correctionFactor
  
  # Combine the un-normed means with the normed results
  merge(datac, ndatac)
}


## get within-subjects CIs for plotting
summary.avg <- summarySEwithin(data = dplyr::filter(lumi.raw.avg), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = "type",
                                  idvar = "subj_id")
kable(summary.avg, caption = "Summary of Avg Looks to Eff and Ineff Actions")


summary.tp <- summarySEwithin(data = dplyr::filter(lumi.raw.tp), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = c("testtype", "testpair"),
                                   idvar = "subj_id")
summary.tp

prop.tp <- summarySEwithin(data = dplyr::filter(lumi.prop.tp), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = "testpair",
                                   idvar = "subj_id")
prop.tp


```

A.
```{r fig2a, fig.width = 20, include=TRUE}

# avg looks to eff and ineff, grouped by experiment, with full variable info 
fig2.raw <- ggplot(data = dplyr::filter(lumi.raw.avg), aes(type, look, fill=experiment))
fig2.raw +
  geom_boxplot(outlier.colour = NA, alpha = 0.5)+
  stat_summary(fun.y = mean, alpha = 0.8, geom = "point", shape=21, size=3, position = "dodge", colour = "black") +
  ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 40)) +
  geom_point(alpha = 0.1)+
  geom_line(alpha = 0.1, aes(group = subj_id))+
  geom_errorbar(data = summary.avg, size = .5, width = 0, aes(ymin=look-ci, ymax=look+ci)) +
  facet_grid(~experiment+training+hab+goal+mitten+causal)+
  scale_x_discrete(labels = c("ineff","eff"))+
  theme_bw(14)+
  theme(legend.position="none", axis.title.x=element_blank())
```
B.
```{r fig2b, fig.width = 20, include=TRUE}
# prop looks ineff, grouped by experiment, with full variable info 
fig2.prop <- ggplot(data = dplyr::filter(lumi.prop.avg), aes(testtype, look, fill=experiment))
fig2.prop + 
  geom_violin(alpha = 0.5, fill = NA, width = 0.5)+
  geom_boxplot(alpha = 0.5)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  ylab("Proportion Looking to Inefficient Reach") +
  xlab(element_blank())+
  geom_jitter(width = .05, alpha = 0.2)+
  coord_cartesian(ylim = c(0.2,0.8)) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", position = position_dodge(width = 5), width = 0) +
  geom_hline(yintercept=0.5, alpha=0.4)+
  facet_grid(~experiment+training+hab+goal+mitten+causal+stimuli)+
  theme_bw(14)+
  theme(strip.placement = "outside") +
  theme(legend.position="none", axis.text.x = element_blank(), axis.title.x=element_blank())

```

**Figure 2.** Looking time in (A) seconds towards the efficient versus inefficient reach, and (B) proportion looking towards the inefficient reach at test across Experiments 1-5 (n=152) and across Experiments 1-5 in Skerry et al. (2013) (n=112). Labels above each panel list the experiment name (Exp. 1-5, SCS Exp. 1-5), type of motor training (none, ineffective non-sticky mittens, or effective sticky mittens), type of action during habituation (constrained or unconstrained by a barrier), goal (state.change or pick.up), whether her actions appeared to be causal (yes.causal or no.causal), and whether the actress wore a mitten (yes.mitten or no.mitten). Error bars around means indicate within-subjects 95% confidence intervals (A) and bootstrapped 95% confidence intervals (B). Individual points (B) or pairs of points (A) indicate data from a single participant. Horizontal bars within boxes indicate medians, and boxes indicate the middle 2 quartiles of data. Violin plots in (B) indicate distribution of data, area scaled proportionally to the number of observations.

***



```{r analysis_prep}
exp1.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.1")
exp2.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.2")
exp3.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.3")
exp4.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4")
exp5.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.5")
exp45.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4" | experiment == "Exp.5")
op <- options(contrasts = c("contr.treatment", "contr.poly")) # treatment contrasts

# function that returns column of standardized betas from lmer model
gen.beta <- function(model) {
  return(t(fixef(model)))
}

# function that computes CIs and returns them in df
gen.ci <- function(model) {
  df <- data.frame(confint(model))
  names(df) <- c("lower", "upper")
  return(df)
}

# function that converts model summary (lmer) to df
gen.m <- function(model) {
  df <- data.frame(coef(summary(model)))
  names(df) <- c("est", "se", "df", "t", "p")
  return(df)
}

# function that converts model summary (lm) to df
gen.lm <- function(model) {
  df <- data.frame(coef(summary(model)))
  names(df) <- c("est", "se", "t", "p")
  return(df)
}

# function that returns age info and number of females in a dataset
ages <- function(longdata) {
  longdata %>% summarize(mean = mean(ageday), min=range(ageday)[1], max=range(ageday)[2], f=sum(sex=="f")/2)
}

# function that returns formatted result from lme4/lmerTest table
report <- function(table, index, places, tails) {
  if (tails == "1") {
    p <- round(table$p[index], places)/2
    howmanytails <- "one-tailed"
  } else {
    p <- round(table$p[index], places)
    howmanytails <- "two-tailed"
  }
  if (p < .001) {
    p <- "<.001"
  } else {
    p <- paste("=", round(p,places), sep = "")
  }
  result <- paste("[", round(table$lower[index], places), ",", round(table$upper[index], places), "], ß=", round(table$beta[index], places), ", B(SE)=", round(table$b[index],places), "(", round(table$se[index],places), "), ", "p", p, ", ", howmanytails, sep = "")
  return(result)
}
```


# Results
## Infants' analysis of causal vs non-causal actions
### Experiment 1
```{r exp1}
# participant info
exp1.info <- ages(exp1.avg)
exp.info <- ages(filter(lumi.raw.avg, paper == "LBS"))

# null model
model0.exp1 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp1.avg, REML = FALSE)

# hypothesis-driven model
model1.exp1 <- lmer(formula = loglook ~ type * hab + (1|subj_id),
               data = exp1.avg, REML = FALSE)
model1.exp1.table <- gen.m(model1.exp1)
model1.exp1.ci <- gen.ci(model1.exp1)[3:6,]

# standardized values
model1.exp1.beta <- lmer(formula = scale(loglook) ~ type * hab + (1|subj_id),
                         data = exp1.avg, REML = FALSE)
model1.exp1.betas <- fixef(model1.exp1.beta)

# identify and check influence of observations
plot(influence(model1.exp1, "subj_id"), which="cook",
     cutoff=4/40, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")
# 2 detected!

model1.exp1.cooks <- lmer(formula = loglook ~ type * hab + (1|subj_id),
               data = filter(exp1.avg, subj_id != "S1_6" & subj_id != "S1_25"), REML = FALSE)
summary(model1.exp1.cooks)

# look at contrasts within each habituation condition
contrasts.exp1 <- cbind(difflsmeans(model1.exp1.beta, test.effs="type:hab")[[1]][,1], difflsmeans(model1.exp1, test.effs="type:hab")[[1]])
names(contrasts.exp1) <- c("beta", "b", "se", "df", "t", "lower", "upper", "p")

```

```{r exp1.table}
exp1 <- kable(cbind(model1.exp1.betas,model1.exp1.table,model1.exp1.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp1.findings <- data.frame(cbind(model1.exp1.betas,model1.exp1.table,model1.exp1.ci))
names(exp1.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")

```

In Experiment 1 (N=`r length(unique(exp1.avg$subj_id))`; `r length(unique(exp1.avg$subj_id))/2` per condition), we asked whether 3-month-old infants (M=`r exp1.info$mean` days, range=`r exp1.info$min`-`r exp1.info$max`, `r exp1.info$f` female) expect a person to reach out and cause an object to change state efficiently. Half of infants were randomly assigned to repeatedly view video clips of a person who reached over a barrier and appeared to cause an object to light up by touching it (H1), while the other half of infants viewed the same reaches except that the barrier was located beyond the goal object, out of the person’s way (H2): a motion that does not appear to adults to be efficiently directed to the goal object.  Then, the infants in both conditions viewed the same pair of alternating test events, in which the barrier was removed and the person reached either efficiently on a novel, direct path or inefficiently on the familiar, indirect path (T1). A mixed effects model with a fixed interaction between habituation and test event and a random intercept for participant identity revealed that infants responded differently to the test events across these two habituation conditions, `r report(exp1.findings, 4, 3, 2)`. Contrasts from this model revealed that when the person’s reaches were initially constrained by a barrier, infants looked longer at the inefficient action (M=`r summary.avg$look[2]`s, SE=`r summary.avg$se[2]`) than the efficient action (M=`r summary.avg$look[1]`s, SE=`r summary.avg$se[1]`) at test, `r report(contrasts.exp1, 2, 3, 1) `. Critically, this looking preference cannot be attributed to low-level responses to the curvilinear reach, because infants in the other condition of the experiment, who were randomly assigned to habituate to otherwise identical videos in which the the barrier was behind the object (H2), looked equally to the inefficient (M=`r summary.avg$look[4]`s, SE=`r summary.avg$se[4]`) and efficient (M=`r summary.avg$look[3]`s, SE=`r summary.avg$se[3]`) actions, `r report(contrasts.exp1, 6, 3, 1)`.



### Experiment 2
```{r exp2}
# participant info
exp2.info <- ages(exp2.avg)

# null model
model0.exp2 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp2.avg, REML = FALSE)

# hypothesis-driven model
model1.exp2 <- lmer(formula = loglook ~ type + (1|subj_id),
               data = exp2.avg, REML = FALSE)
model1.exp2.table <- data.frame(coef(summary(model1.exp2)))
model1.exp2.ci <- gen.ci(model1.exp2)[3:4,]

# standardized values
model1.exp2.beta <- lmer(formula = scale(loglook) ~ type + (1|subj_id),
                         data = exp2.avg, REML = FALSE)
model1.exp2.betas <- fixef(model1.exp2.beta)

# identify and check influence of observations
# model.exp2.cooks <- exclude.cooks(model1.exp2, exp2.avg, "subj_id")
plot(influence(model1.exp2, "subj_id"), which="cook",
     cutoff=4/20, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")
# no influential observations

# comparing results to Exp 1
causality12 <- lumi.raw.avg %>%
  filter(experiment == 'Exp.1' | experiment == "Exp.2") %>%
  filter(hab == "constrained")

model1.exp12 <- lmer(formula = loglook ~ type * causal + (1|subj_id) + (1|experiment),
                     data = causality12, REML=FALSE)
model1.exp12.table <- data.frame(coef(summary(model1.exp12)))
model1.exp12.ci <- gen.ci(model1.exp12)[4:7,]

# standardized betas
model1.exp12 <- lmer(formula = scale(loglook) ~ type * causal + (1|subj_id) + (1|experiment),
                     data = causality12, REML=FALSE)
model1.exp12.betas <- fixef(model1.exp12)

# look at contrasts within each caual condition
contrasts.exp12 <- difflsmeans(model1.exp12, test.effs="type:causal")[[1]]
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), '-', '')
```


```{r exp2.table}
exp2 <- kable(cbind(model1.exp2.betas,model1.exp2.table,model1.exp2.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp2.findings <- data.frame(cbind(model1.exp2.betas,model1.exp2.table,model1.exp2.ci))
names(exp2.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```

```{r exp12.table}
exp12 <- kable(cbind(model1.exp12.betas,model1.exp12.table,model1.exp12.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp12.findings <- data.frame(cbind(model1.exp12.betas,model1.exp12.table,model1.exp12.ci))
names(exp12.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```

In Experiment 2 (N=`r length(unique(exp2.avg$subj_id))`), we asked whether infants’ analysis of the causal structure of an action is critical to their understanding of this action as intentional, as suggested by past studies of causal perception (Michotte 1963; Muentener and Carey 2010; Leslie 1984).  We tested whether infants’ sensitivity to the efficiency of the reaching action from Experiment 1 depended on their construal of the person as a causal agent (an agent contacting an object, thereby changing its state) or on lower-level scene features (an agent reaching towards an object that happens to illuminate), by manipulating the spatiotemporal contingency of this action. In Experiment 2, pre-registered at https://osf.io/a5byn/, infants (M=`r exp2.info$mean` days, range=`r exp2.info$min`-`r exp2.info$max`, `r exp2.info$f` female) were habituated to videos identical to H1, except that the person’s hand stopped 50 pixels above the object (approximately 2 cm on the presentation screen), and the object changed state after a 0.5 second delay. At test, the person reached efficiently or inefficiently in the absence of the barrier with the same point above the object as in habituation trials (T2). We found that infants looked equally between the inefficient (M=`r summary.avg$look[6]`s, SE=`r summary.avg$se[6]`) and efficient (M=`r summary.avg$look[5]`s, SE=`r summary.avg$se[5]`) reach, `r report(exp2.findings, 2, 3, 2)`, mixed effects model with trial type as fixed effect and participants as a random intercept, a result that differed from infants’ responses to the causally effective reaches in Experiment 1 (H1), `r report(exp12.findings, 4, 3, 2)`, mixed effects model with fixed interaction between causality and trial type.

### Experiment 3
```{r exp3}
# participant info
exp3.info <- ages(exp3.avg)

# null model
model0.exp3 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp3.avg, REML = FALSE)

model1.exp3 <- lmer(formula = loglook ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)
model1.exp3.table <- data.frame(coef(summary(model1.exp3)))
model1.exp3.ci <- gen.ci(model1.exp3)[3:6,]

# standardized values
model1.exp3.beta <- lmer(formula = scale(loglook) ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)
model1.exp3.betas <- fixef(model1.exp3.beta)

# identify and check influence of observations
# model.exp3.cooks <- exclude.cooks(model1.exp3, exp3.avg, exp3.avg$subj_id)
plot(influence(model1.exp3, "subj_id"), which="cook",
     cutoff=4/52, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")
# no influential observations

# look at contrasts within each caual condition
contrasts.exp3 <- cbind(difflsmeans(model1.exp3.beta, test.effs="type:causal")[[1]][,1], difflsmeans(model1.exp3, test.effs="type:causal")[[1]])
names(contrasts.exp3) <- c("beta", "b", "se", "df", "t", "lower", "upper", "p")
```

```{r exp3.table}
exp3 <- kable(cbind(model1.exp3.betas,model1.exp3.table,model1.exp3.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp3.findings <- data.frame(cbind(model1.exp3.betas,model1.exp3.table,model1.exp3.ci))
names(exp3.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```

Experiment 3 (N=`r length(unique(exp3.avg$subj_id))`; `r length(unique(exp3.avg$subj_id))/2` per condition) attempted to replicate the findings from Experiments 1 and 2 that infants expect causally effective reaches to be efficient, but do not expect efficiency when presented with same actions that are not spatiotemporally continuous. In this experiment, pre-registered at https://osf.io/f2hvd/, we randomly assigned infants (M=`r exp3.info$mean` days, range=`r exp3.info$min`-`r exp3.info$max`, `r exp3.info$f` female) to H1 and T1, or H3 and T2: a design that enables us to directly compare infants’ responses to the test displays as a function of causal information, using experimenters who are blind not only to the test events but to the infants' habituation condition. The findings of this experiment replicated those of the previous two studies:  Infants' tendency to view the agent's actions as efficiently directed to the goal object again depended on the presentation of actions that elicit an impression of contact causality, in which the agent's hand contacted the object at the time of the object's change of state, `r report(exp3.findings, 4, 3, 2)`, mixed effects model with fixed interaction of causality and test event. As in Experiment 1, infants looked longer at the inefficient reach (M=`r summary.avg$look[10]`s, SE=`r summary.avg$se[10]`) than the efficient reach (M=`r summary.avg$look[9]`s, SE=`r summary.avg$se[9]`) when the person’s actions were causally effective, `r report(contrasts.exp3, 6, 3, 1)`, and as in Experiment 2, infants looked equally to the inefficient (M=`r summary.avg$look[8]`s, SE=`r summary.avg$se[8]`) and efficient (M=`r summary.avg$look[7]`s, SE=`r summary.avg$se[7]`) reaches when the gap between her hand and the object suggested that her action was causally ineffective, `r report(contrasts.exp3, 1, 3, 1)`. Together, Experiments 1-3 show that pre-reaching infants apply the principle of efficiency (Gergely & Csibra, 2003) to reaching actions that they themselves have never experienced, and that they only apply this principle to actions that appear to cause changes in the world.

## Infants’ analysis of entrainment actions
### Experiments 4 and 5
```{r exp45}
# participant info
exp4.info <- ages(exp4.avg)
exp5.info <- ages(exp5.avg)

# null model
model0.exp45 <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp45.avg, REML = FALSE)

model1.exp45 <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)
model1.exp45.table <- gen.m(model1.exp45)
model1.exp45.ci <- gen.ci(model1.exp45)[4:7,]

# standardized values
model1.exp45.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)
model1.exp45.betas <- fixef(model1.exp45.beta)

# identify and check influence of observations
# model1.exp45.cooks <- exclude.cooks(model1.exp45, exp45.avg, "subj_id")
plot(influence(model1.exp45, "subj_id"), which="cook",
     cutoff=4/40, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")

# 3 influential observations identified
model1.exp45.cooks <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = filter(exp45.avg, subj_id != "S4_20" & subj_id != "S5_10" & subj_id != "S5_18"), REML=FALSE)
summary(model1.exp45.cooks)


# look at contrasts within each habituation condition
contrasts.exp45 <- cbind(difflsmeans(model1.exp45.beta, test.effs="type:mitten")[[1]][,1], difflsmeans(model1.exp45, test.effs="type:mitten")[[1]])
names(contrasts.exp45) <- c("beta", "b", "se", "df", "t", "lower", "upper", "p")
```


```{r exp45.table}
exp45 <- kable(cbind(model1.exp45.betas,model1.exp45.table,model1.exp45.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp45.findings <- data.frame(cbind(model1.exp45.betas,model1.exp45.table,model1.exp45.ci))
names(exp45.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```


```{r exp5.scs}
exp5.scs <- lumi.raw.avg %>% filter(experiment == "Exp.5" | experiment == "SCS.Exp.3")

# null model
model0.exp5.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp5.scs, REML = FALSE)

model1.exp5.scs <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)
model1.exp5.scs.table <- gen.m(model1.exp5.scs)
model1.exp5.scs.ci <- gen.ci(model1.exp5.scs)[4:7,]

# standardized values
model1.exp5.scs.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)
model1.exp5.scs.betas <- fixef(model1.exp5.scs.beta)

# identify and check influence of observations
plot(influence(model1.exp5.scs, "subj_id"), which="cook",
     cutoff=4/40, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")
# one identified

model1.exp5.scs.cooks <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = filter(exp5.scs, subj_id != "SCS_S3_12"), REML=FALSE)
summary(model1.exp5.scs.cooks)
                     
# look at contrasts within each caual condition
contrasts.exp5.scs <- cbind(difflsmeans(model1.exp5.scs.beta, test.effs="type:mitten")[[1]][,1], difflsmeans(model1.exp5.scs, test.effs="type:mitten")[[1]])
names(contrasts.exp5.scs) <- c("beta", "b", "se", "df", "t", "lower", "upper", "p")
```


```{r exp5.scs.table}
exp5.scs <- kable(cbind(model1.exp5.scs.betas,model1.exp5.scs.table,model1.exp5.scs.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp5.scs.findings <- data.frame(cbind(model1.exp5.scs.betas,model1.exp5.scs.table,model1.exp5.scs.ci))
names(exp5.scs.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```


```{r exp4.scs}
exp4.scs <- lumi.raw.avg %>% filter(experiment == "Exp.4" | experiment == "SCS.Exp.3")

# null model
model0.exp4.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp4.scs, REML = FALSE)

model1.exp4.scs <- lmer(formula = loglook ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)
model1.exp4.scs.table <- gen.m(model1.exp4.scs) 
model1.exp4.scs.ci <-  gen.ci(model1.exp4.scs) [4:7,]

# standardized values
model1.exp4.scs.beta <- lmer(formula = scale(loglook) ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)
model1.exp4.scs.betas <- fixef(model1.exp4.scs.beta)

# identify and check influence of observations
# model1.exp4.scs.cooks <- exclude.cooks(model1.exp4.scs, exp4.scs, "subj_id")
plot(influence(model1.exp4.scs, "subj_id"), which="cook",
     cutoff=4/40, sort=TRUE,
     xlab="Cook´s Distance",
     ylab="Subject ID")
# 2 subjects identified

model1.exp4.scs.cooks <- lmer(formula = loglook ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = filter(exp4.scs, subj_id != "SCS_S3_12" & subj_id != "S4_9"), REML=FALSE)
summary(model1.exp4.scs.cooks)

# look at contrasts within each experiment
contrasts.exp4.scs <- cbind(difflsmeans(model1.exp4.scs.beta, test.effs="type:experiment")[[1]][,1], difflsmeans(model1.exp4.scs, test.effs="type:experiment")[[1]])
names(contrasts.exp5.scs) <- c("beta", "b", "se", "df", "t", "lower", "upper", "p")
```

```{r exp4.scs.table}
exp4.scs <- kable(cbind(model1.exp4.scs.betas,model1.exp4.scs.table,model1.exp4.scs.ci), col.names = c("beta", "b", "se", "df", "t", "p", "lower", "upper"))

exp4.scs.findings <- data.frame(cbind(model1.exp4.scs.betas,model1.exp4.scs.table,model1.exp4.scs.ci))
names(exp4.scs.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```

Why do infants succeed in these experiments without motor training, yet fail in the experiments of SCS? First, pre-reaching infants may struggle to understand the causal structure of reaching for and retrieving an object without the relevant motor experience. Second, pre-reaching infants may not interpret the reach of a mittened hand, one that looks different from most hands they see, as intentional (Guajardo & Woodward, 2004) and causally effective with respect to a particular object without the relevant experience of observing and experiencing their own mittened hands acting causally towards a specific set of objects during training.  Consistent with the latter possibility, mittens training has been found to enhance understanding of observed actions in previous research only when the observed agent wore mittens like those worn by the infant (Amanda Woodward, 2008), and only when agent reached for the same objects as the infants did during training (Gerson & Woodward, 2014).

To ask whether surface properties of the hand reaching affect infants’ interpretation of the intentionality of these reaches, we ran two additional experiments. In Experiment 4 (N=`r length(unique(exp4.avg$subj_id))`), infants (M=`r exp4.info$mean` days, range=`r exp4.info$min`-`r exp4.info$max`, `r exp4.info$f` female) were habituated to and tested on events where a person reach for and pick up an object identical to those from Experiments 1-3 while wearing the same mitten (H4, T3). In Experiment 5 (N=`r length(unique(exp5.avg$subj_id))`), infants (M=`r exp5.info$mean` days, range=`r exp5.info$min`-`r exp5.info$max`, `r exp5.info$f` female) saw almost identical videos to those from Experiment 4 except that the person reached with a bare hand (H5, T4). 

We found that infants looked marginally longer at the inefficient (M=`r summary.avg$look[14]`s, SE=`r summary.avg$se[14]`) than the efficient (M=`r summary.avg$look[12]`s, SE=`r summary.avg$se[12]`) reach of the bare hand, `r report(contrasts.exp45, 1, 3, 1)` in Experiment 5, whereas they did not distinguish the inefficient (M=`r summary.avg$look[12]`s, SE=`r summary.avg$se[12]`) from the efficient (M=`r summary.avg$look[11]`s, SE=`r summary.avg$se[11]`) action of the mittened hand in Experiment 4, `r report(contrasts.exp45, 6, 3, 1)`. However, these two patterns of looking did not differ from each other, `r report(exp45.findings, 4, 3, 2)`, mixed effects model with fixed interaction between mitten and test trial, random intercept for participants.

We also compared these results against those from SCS Experiment 3, wherein infants received no mittens training and viewed a person reaching with a mittened hand. The results of Experiment 5 (no mitten) differed from those in SCS Experiment 3 (mitten), `r report(exp5.scs.findings, 4, 3, 2)`, whereas the results from Experiment 4 (mitten) did not differ from those in SCS Experiment 3 (mitten), `r report(exp4.scs.findings, 4, 3, 2)`. This finding accords with reports that young infants trained with mittens view an agent's reach as goal-directed only if the agent wears the same mittens and interacts with the same objects as they did during training (Gerson & Woodward, 2014; Amanda Woodward, 2008). Nevertheless, the differences in infants' responses to gloved and ungloved hands are not robust in our studies and merit further investigation.  


## Meta-analytic Results: Experiments 1-5 and SCS

Across Experiments 1-5, we found that pre-reaching infants apply expectations of efficient action to a person who pursues the goal of causing a change in an object while wearing a mitten, but do not apply the same expectation to the same person wearing the same mitten when she picks up the same object. Thus, we suggest that one key difference between the state change events we used in the present experiments, and the pickup events used in SCS and Experiments 4-5, is the causal transparency of these actions: Three-month-old infants do not know how to reach for and grasp objects, and thus may struggle to understand how grasping an object could cause it to rise and move closer to the person reaching for it, thereby fulfilling the goal of the agent to retrieve it. Indeed, infants’ own ability to produce power grasps (the actions tested in Experiment 4 and 5 and in SCS) predicts their ability to represent such grasps as directed towards an object (Bakker et al., 2015). Although the infants in our experiments will not master these grasping actions until around 5 months of age (von Hofsten, 1980), these infants may nevertheless possess the intuition that causal agents behave efficiently, an expectation they apply to events in which an object changes state on contact with an agent's hand.

To assess the unique effects of our experimental manipulations, and to compare our data directly to those from SCS, we performed a meta-analysis over the 12 conditions (total N=`r length(unique(lumi.raw.avg$subj_id))`) from these two papers. Our analytic approach allows us to assess the independent effects of a wide array of manipulations, including variations in motor training, habituation, goal, and surface properties, on infants’ expectations about efficient reaching, while controlling participant variables like age and sex, and also modeling the nested structure of the data (e.g. looks clustered within experiments and within papers). For ease of interpretation, we use average proportion looking to the inefficient action in this analysis, following SCS.



```{r meta}
# set contrasts for analysis - compare effects against the grand mean
op <- options(contrasts = c("contr.sum", "contr.poly"))

# strangely, we need to flip reference levels so that ref gets compred against grand mean
lumi.wide$goal <- relevel(lumi.wide$goal, ref = "state.change")
lumi.wide$hab <- relevel(lumi.wide$hab, ref = "constrained")
lumi.wide$mitten <- relevel(lumi.wide$mitten, ref = "yes.mitten")
lumi.wide$training <- factor(lumi.wide$training, levels = c("effective.training", "ineffective.training", "no.training"))
lumi.wide$causal <- relevel(lumi.wide$causal, ref = "yes.causal")

# full exploratory model
model1.all <- lmer(formula = prop.ineff.all ~ training + goal + hab + causal + mitten + (1|experiment) + (1|ageday) + (1|sex) + (1|paper), data = lumi.wide)
model1.all.table <- gen.m(model1.all)
model1.all.ci <- gen.ci(model1.all)[6:12,]

# standardized values
model1.all.beta <- lmer(formula = scale(prop.ineff.all) ~ training + goal + hab + causal + mitten + (1|experiment) + (1|ageday) + (1|sex) + (1|paper), data = lumi.wide)
model1.all.betas <- fixef(model1.all.beta)

```

***
**Table 2.** Regression table for model investigating predictors of sensitivity to action efficiency across Experiment 1-5 and all experiments from Skerry et al. (2013) (total N=264). Dependent measure is proportion looking towards the inefficient reach, averaged across 3 test trials during test. Categorical predictors were coded using sum contrasts, and fixed effects from the model should therefore be interpreted with respect to the grand mean (with respect to 0). Model formula: `prop.ineff.all ~ training + goal + hab + causal + mitten + (1|experiment) + (1|ageday) + (1|sex) + (1|paper)`.


```{r meta_table, include=TRUE}
kable(cbind(model1.all.betas, model1.all.table, model1.all.ci), col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))

meta.findings <- data.frame(cbind(model1.all.betas, model1.all.table, model1.all.ci))
names(meta.findings) <- c("beta", "b", "se", "df", "t", "p", "lower", "upper")
```

```{r meta_figure, include=TRUE, fig.width=12, cache=FALSE}
# two ways of plotting: first, plotting model effects
# plot_model(model1.all, sort.est=TRUE, show.values=TRUE, digits=3, colors = "bw",  title = "prop.ineff.all ~ training + hab + goal + mitten + causal + (1+first.test|experiment) + (1|ageday) + (1|sex) + (1|paper)")

# second, plotting model estimates for each level of categorical variable
plot(allEffects(model1.all),
     main = NA,
     ylim=c(0.37,0.63),
     ylab="Proportion Looks to Inefficient",
     ci.style="bars",
     lwd=4,
     grid=TRUE,
     colors={c("black", "red")}
)

```


**Figure 3.** Effect plots for model investigating predictors of sensitivity to action efficiency across Experiments 1-5 and Skerry et al. (2013). Each point shows estimates of effects at each level of all categorical predictors. Error bars indicate 95% confidence intervals. See Table 2 for full results.

***

This analysis confirms that first-person action experience is not the only way to enhance infants’ appreciation of the causal and intentional aspects of action. We found that infants’ expectations were stronger when the observed action was spatiotemporally continuous its effect (i.e., appeared to be causal), `r report(meta.findings, 6, 3, 2)`, when infants received effective motor training (sticky mittens), relative to no training `r report(meta.findings, 2, 3, 2)`, when the observed agent's actions were constrained by a barrier and were efficiently adapted to that barrier, relative to an agent whose actions followed the same trajectory but were unconstrained by any barrier and therefore were inefficient, `r report(meta.findings, 5, 3, 2)`, and when the agent pursued a state change goal, relative to a pickup goal, `r report(meta.findings, 4, 3, 2)`. We also found that infants’ expectations were not affected when they received ineffective motor training (non-sticky mittens), relative to no training, `r report(meta.findings, 3, 3, 2)`, or when the actor wore a mitten, relative to no mitten `r report(meta.findings, 7, 3, 2)`.



# Supplemental Results

## Assessing distribution of looks

```{r distplot, fig.width = 7, include=TRUE}
# is a lognormal transformation justified given the distribution of looks?
fig.S1 <- ggplot(data = dplyr::filter(lumi.raw.avg), aes(look, fill=experiment, colour = experiment))
fig.S1 +
  geom_density(alpha = 0.5)+
  # geom_text(aes(experiment))+
  theme_linedraw(15)+
  xlab("Looking Time (s)")

normal.ll <- fitdistr(lumi.raw.avg$look, "normal")$loglik
lognormal.ll <- fitdistr(lumi.raw.avg$look, "lognormal")$loglik
```

**Figure S1.** Density plot of looking times during test across Experiments 1-5, and Experiments 1-5 from Skerry et al. (2013) (N=`r length(unique(lumi.wide$subj_id))`). Maximum-likelihood fitting revealed that the lognormal distribution (log likelihood=`r lognormal.ll`) provides a better fit to these data than the normal distribution (log likelihood=`r normal.ll`).

***

## Assessing reliability 

```{r relplot, include=TRUE}
relplot <- ggplot(data = lumi.rel, aes(experiment, gap, fill = experiment))
relplot + 
  # geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  geom_jitter(width = .05, alpha = 0.2)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = 0.05) +
  xlab("Experiment") + ylab("Discrepancy (New - Original) (s)") +
  theme_linedraw(15)+
  theme(legend.position="none")  
```

**Figure S2.** Discrepancy between original and new coding of looking times during test trials in seconds. 

***

## Attention during habituation across Exp 1-5

```{r habplot, fig.width = 7, include=TRUE}
# habituation sum
hab.plot <- ggplot(data = filter(lumi.wide, paper == "LBS"), aes(experiment, total_hab, fill = experiment))
hab.plot + 
  geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  geom_jitter(width = .05, alpha = 0.2)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = 0.05) +
  xlab("Experiment") + ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 500)) +
  theme_linedraw(15)+
  theme(legend.position="none")
```

**Figure S3.** Total looking time in seconds during habituation across Experiment 1-5. Error bars around means indicate bootstrapped 95% confidence intervals. Individual points indicate data from a single participant. Horizontal bars within boxes indicate medians, and boxes indicate the middle 2 quartiles of data. Violin plots in indicate distribution of data, area scaled proportionally to the number of observations. 

***

```{r hab.analysis}

# assessing effect of experimental manipulations on hab time
hab1 <- lmer(total_hab ~ ageday + sex + hab + goal + mitten + causal + (1|experiment),
             data = filter(lumi.wide, paper == "LBS"), REML=FALSE)
hab1.table <- gen.m(hab1)
hab1.ci <- gen.ci(hab1)
```

To ask whether infants' attention during habituation was affected by experimental manipulations across Experiment 1-5 (constrained vs unconstrained habituation, state change vs pickup goal, mitten vs no mitten, and causally contingent vs noncontigent action), and varied by gender and age, we fit a mixed effects model on these fixed effects and experiment (1-5) as a random intercept. We found that the only robust predictor of attention during habituation was age, [`r hab1.ci$lower[4]`, `r hab1.ci$upper[4]`], B=`r hab1.table$est[2]`, p=`r hab1.table$p[2]`, two-tailed, such that older infants looked for a shorter time overall than younger infants.

## Exploring effect of test trial order, attention during habituation, age in days, and sex across Exp 1-5

```{r explore}
# set contrasts for analysis - compare effects against the grand mean
op <- options(contrasts = c("contr.sum", "contr.poly"))

emodel.exp1 <- lmer(loglook ~ hab * type * first.test + total_hab + sex + ageday + (1|subj_id), REML=FALSE, data = exp1.avg)
emodel.exp1.table <- gen.m(emodel.exp1)
emodel.exp1.ci <- gen.ci(emodel.exp1)[3:13,]
emodel.exp1.betas <- fixef(lmer(scale(loglook) ~ hab * type * first.test + scale(total_hab) + sex + scale(ageday) + (1|subj_id), REML = FALSE, data = exp1.avg))

emodel.exp2 <- lmer(loglook ~ type * first.test + total_hab + sex + ageday + (1|subj_id), REML = FALSE, data = exp2.avg)
emodel.exp2.table <- gen.m(emodel.exp2)
emodel.exp2.ci <- gen.ci(emodel.exp2)[3:9,]
emodel.exp2.betas <- fixef(lmer(scale(loglook) ~ type * first.test + scale(total_hab) + sex + scale(ageday) + (1|subj_id), REML = FALSE, data = exp2.avg))

emodel.exp3 <- lmer(loglook ~ causal * type * first.test + total_hab + sex + ageday + (1|subj_id), REML = FALSE, data = exp3.avg)
emodel.exp3.table <- gen.m(emodel.exp3)
emodel.exp3.ci <- gen.ci(emodel.exp3)[3:14,]
emodel.exp3.betas <- fixef(lmer(scale(loglook) ~ causal * type * first.test + scale(total_hab) + sex + scale(ageday) + (1|subj_id), REML=FALSE, data = exp3.avg))

emodel.exp4 <- lmer(loglook ~ type * first.test + total_hab + sex + ageday + (1|subj_id), REML=FALSE, data = exp4.avg)
emodel.exp4.table <- gen.m(emodel.exp4)
emodel.exp4.ci <- gen.ci(emodel.exp4)[3:9,]
emodel.exp4.betas <- fixef(lmer(scale(loglook) ~ type * first.test + scale(total_hab) + sex + scale(ageday) + (1|subj_id), REML=FALSE, data = exp4.avg))

emodel.exp5 <- lmer(loglook ~ type * first.test + total_hab + sex + ageday + (1|subj_id), REML = FALSE, data = exp5.avg)
emodel.exp5.table <- gen.m(emodel.exp5)
emodel.exp5.ci <- gen.ci(emodel.exp5)[3:9,]
emodel.exp5.betas <- fixef(lmer(scale(loglook) ~ type * first.test + scale(total_hab) + sex + scale(ageday) + (1|subj_id), REML=FALSE, data = exp5.avg))
```

To explore the additional effects of test trial order (inefficient or efficient first), attention during habituation, age in days, and sex on attention during test, we ran one linear model per experiment including an interaction between test event order and test event in Experiments 2, 4, and 5, an interaction between these factors and habituation in Experiment 1, and an interaction between these factors and causal contingency in Experiment 3. 

Regression tables for each of these models is below. In general, we find no effect of sex or age, and we consistently find that infants who look longer during habituation also are more attentive during test. 

In Experiment 1, we also find that infants randomly assigned to habituate to a rational agent look longer overall at test, [`r emodel.exp1.ci$lower[2]`, `r emodel.exp1.ci$upper[2]`], B=`r emodel.exp1.table$est[2]`, p=`r emodel.exp1.table$p[2]`, two-tailed, and that infants randomly assigned to view the efficient reach first look longer overall at test, [`r emodel.exp1.ci$lower[4]`, `r emodel.exp1.ci$upper[4]`], B=`r emodel.exp1.table$est[4]`, p=`r emodel.exp1.table$p[4]`, two-tailed.

In Experiment 2, we also find that infants randomly assigned to look at the efficient reach first look longer overall at test, [`r emodel.exp2.ci$lower[3]`, `r emodel.exp2.ci$upper[3]`], B=`r emodel.exp2.table$est[3]`, p=`r emodel.exp2.table$p[3]`, two-tailed.


### Experiment 1

```{r, include = TRUE}
kable(cbind(emodel.exp1.betas, emodel.exp1.table, emodel.exp1.ci), col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))

```



### Experiment 2

```{r, include = TRUE}

kable(cbind(emodel.exp2.betas, emodel.exp2.table, emodel.exp2.ci), col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))

```



### Experiment 3

```{r, include = TRUE}
kable(cbind(emodel.exp3.betas, emodel.exp3.table, emodel.exp3.ci), col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))

```



### Experiment 4

```{r, include = TRUE}
kable(cbind(emodel.exp4.betas, emodel.exp4.table, emodel.exp4.ci),col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))
```



### Experiment 5

```{r, include = TRUE}
kable(cbind(emodel.exp5.betas, emodel.exp5.table, emodel.exp5.ci),col.names = c("Standardized Estimate (ß)", "Estimate (B)", "Standard Error (SE)", "df", "t", "p", "95% CI (Lower)", "95% CI (Upper)"))
```

## Reliability
```{r reliability}
exp1.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.1")$newlook, filter(lumi.rel, experiment == "Exp.1")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp2.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.2")$newlook, filter(lumi.rel, experiment == "Exp.2")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp3.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.3")$newlook, filter(lumi.rel, experiment == "Exp.3")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp4.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.4")$newlook, filter(lumi.rel, experiment == "Exp.4")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp5.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.5")$newlook, filter(lumi.rel, experiment == "Exp.5")$look.orig), model = "twoway", type = "agreement", unit = "single")

```


To assess reliability, 50% of test trials from participants across Experiments 1-5 (`r length(unique(lumi.wide$subj_id))/2` participants, `r nrow(lumi.rel)` trials) were randomly selected and coded by additional researchers who were unaware of experimental condition, and test trial order. The intraclass correlation coefficient (ICC) between the original data, and this newly coded data, was `r exp1.rel$value` [`r exp1.rel$lbound`, `r exp1.rel$ubound`], `r exp2.rel$value` [`r exp2.rel$lbound`, `r exp2.rel$ubound`], `r exp3.rel$value` [`r exp3.rel$lbound`, `r exp3.rel$ubound`], `r exp4.rel$value` [`r exp4.rel$lbound`, `r exp4.rel$ubound`], `r exp5.rel$value` [`r exp5.rel$lbound`, `r exp5.rel$ubound`], for Experiments 1 through 5, respectively.

## Exclusion info

**Table S1.** Tally of infants who participated in Experiments 1-5 but were excluded in our final sample. These exclusion criteria were set prior to the start of data collection, but vary slightly by experiment (e.g. we relaxed our definition of inattentiveness from excluding all data from a participant if they missed a test trial in Experiment 1, to excluding data from just that trial in Experiments 2-5). 

Experiment | Fussiness | Inattentiveness | Caregiver Interference | Experimenter/Coding Error | Technical Failure | Total 
---------- | --------- | --------------- | ---------------------- | ------------------------- | ----------------- | -----
Exp.1 | 9 | 5 | 1 | 12 | 3 | 30
Exp.2 | 0 | 0 | 0 | 2 | 0 | 2
Exp.3 | 6 | 0 | 0 | 2 | 0 | 8
Exp.4 | 7 | 0 | 0 | 2 | 0 | 7
Exp.5 | 6 | 0 | 0 | 1 | 2 | 9
**Total** | 28 | 5 | 1 | 19 | 5 | 50
***
