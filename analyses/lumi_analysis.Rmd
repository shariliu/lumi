
---
title: "Pre-reaching infants expect causal agents to reach efficiently" 
author: "Shari Liu"
date: "July 31 2018"
output: html_document
---

# Tables and Figures

**Table 1.** Summary of conditions, design, and sample sizes of Experiments 1-5, and SCS Experiments 1-5. Conditions listed under a single experiment (e.g. Exp 1 and 3) included random assignment to condition. For stimuli, see Fig 1. * indicates direct replication.

Experiment | N | Training |  Goal | Habituation | Causal | Mitten | Stimuli
---------- | - | ---------| ----- | ----------- | ------ | ------ | -------
1 | 20 | none | state change | constrained | yes | yes | H1, T1
1 | 20 | none | state change | unconstrained | yes | yes | H2, T1
2 | 20 | none | state change | constrained | no | yes | H3, T2
3* | 26 | none |  state change | constrained | yes | yes | H1, T1
3* | 26 | none | state change | constrained | no | yes | H3, T2
4 | 20 | none | pick up | constrained | yes | yes | H4, T3
5 | 20 | none | pick up | constrained | yes | no | H5, T4
SCS 1 | 20 | effective | pick up | constrained | yes | yes |
SCS 2 | 20 | ineffective | pick up | constrained | yes | yes |
SCS 3 | 20 | none | pick up | constrained | yes | yes |
SCS 4* | 26 | effective | pick up | constrained | yes | yes |
SCS 5 | 26 | effective | pick up |unconstrained | yes | yes |

![**Figure 1.** Still frames from videos shown to participants in Experiments 1-5, including stimuli from habituation (H1-H5) and test (T1-T4). In each video, a person reached for and caused a change in an object (H1-H3, T1-T2), or picked up the object (H4-H5, T3-T4), over a barrier (H1- H2, H4-H5) or over empty space (H2, T1-T4), and either acted on the object by contacting it (H1-H2, H4-H5, T1, T3-T4) or produced the same effect from a distance of 50 pixels, after a 0.5s delay (H3, T2). During test (T1-T4), the person either reached directly for the object (T1-T4, left panel), or in a curvilinear fashion (T1-T4, right panel).](/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/fig1.jpeg)

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE
)

## load required packages
ipak <- function (pkg) {
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

packages <- c("tidyverse", "Hmisc", "lattice", "multcomp", "lsmeans", "schoRsch", "influence.ME", "devtools", "skimr", "simr", "lme4", "effects", "lmerTest", "ICC", "compute.es", "pwr", "stringr")

ipak(packages)
```

```{r import, include = FALSE}

lumi.wide <- read.csv("/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/lumi_data_deid.csv", header = TRUE) # change to your local directory

str(lumi.wide)
```

```{r prep_data, include = FALSE, cache = TRUE, dependson="lumi_wide"}
# convert to long format
lumi.long <- gather(lumi.wide, type, look, ineff.1:avg.eff)
str(lumi.long)
lumi.long$type <- factor(lumi.long$type)
lumi.long$loglook <- log(lumi.long$look)
lumi.long$testpair <- NA
lumi.long$testtype <- NA

# assign test pair and type info to data from individual test trials
for (i in 1:nrow(lumi.long)) {
  if (lumi.long$type[i] == "ineff.1" | lumi.long$type[i] == "prop.ineff1") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "ineff.2" | lumi.long$type[i] == "prop.ineff2") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "ineff.3" | lumi.long$type[i] == "prop.ineff3") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "third"
  }
  else if (lumi.long$type[i] == "eff.1") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "eff.2") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "eff.3") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "third"
  }
}


# set baseline levels of all categorical predictors for analyses later on
lumi.long$testtype <- factor(lumi.long$testtype)
lumi.long$testtype <- relevel(lumi.long$testtype, ref = "efficient")
lumi.long$testpair <- factor(lumi.long$testpair)
lumi.long$testpair <- relevel(lumi.long$testpair, ref = "first")
lumi.wide$first.test <- relevel(lumi.wide$first.test, ref = "efficient")
lumi.wide$goal <- relevel(lumi.wide$goal, ref = "pick.up")
lumi.wide$hab <- relevel(lumi.wide$hab, ref = "unconstrained")
lumi.wide$mitten <- relevel(lumi.wide$mitten, ref = "no.mitten")
lumi.wide$training <- relevel(lumi.wide$training, ref = "no.training")
lumi.wide$causal <- relevel(lumi.wide$causal, ref = "no.causal")
lumi.wide$sex <- relevel(lumi.wide$sex, ref = "m")
lumi.wide$habbed <- factor(lumi.wide$habbed)
lumi.wide$habbed <- relevel(lumi.wide$habbed, ref = "0")
lumi.wide$pref <- relevel(lumi.wide$pref, ref = "eff")

# section data based on dv
lumi.prop.avg <- filter(lumi.long, type == "prop.ineff.all")
lumi.raw.avg <- filter(lumi.long, type == "avg.eff" | type == "avg.ineff")
lumi.prop.tp <- filter(lumi.long, type == "prop.ineff1" | type == "prop.ineff2" | type == "prop.ineff3")
lumi.raw.tp <- filter(lumi.long, type == "ineff.1" | type == "ineff.2" | type == "ineff.3" | type == "eff.1" |type == "eff.2"| type == "eff.3")
```

```{r distribution, include = FALSE,  cache = TRUE}
# is a lognormal transformation justified given the distribution of looks?
hist(lumi.raw.avg$look, main = NULL, breaks = 10, xlab = "Looking Time (s)")
fitdistr(lumi.raw.avg$look, "normal")$loglik
fitdistr(lumi.raw.avg$look, "lognormal")$loglik
```

```{r within_variance, include = FALSE}
## Retrieved from : http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#error-bars-for-within-subjects-variables
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the "mean" column    
  datac <- plyr::rename(datac, c("mean" = measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}
## Norms the data within specified groups in a data frame; it normalizes each
## subject (identified by idvar) so that they have the same mean, within each group
## specified by betweenvars.
##   data: a data frame.
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   na.rm: a boolean that indicates whether to ignore NA's
normDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
  library(plyr)
  
  # Measure var on left, idvar + between vars on right of formula.
  data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,
                         .fun = function(xx, col, na.rm) {
                           c(subjMean = mean(xx[,col], na.rm=na.rm))
                         },
                         measurevar,
                         na.rm
  )
  
  # Put the subject means with original data
  data <- merge(data, data.subjMean)
  
  # Get the normalized data in a new column
  measureNormedVar <- paste(measurevar, "_norm", sep="")
  data[,measureNormedVar] <- data[,measurevar] - data[,"subjMean"] +
    mean(data[,measurevar], na.rm=na.rm)
  
  # Remove this subject mean column
  data$subjMean <- NULL
  
  return(data)
}

## Summarizes data, handling within-subjects variables by removing inter-subject variability.
## It will still work if there are no within-S variables.
## Gives count, un-normed mean, normed mean (with same between-group mean),
##   standard deviation, standard error of the mean, and confidence interval.
## If there are within-subject variables, calculate adjusted values using method from Morey (2008).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   withinvars: a vector containing names of columns that are within-subjects variables
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,
                            idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
  
  # Ensure that the betweenvars and withinvars are factors
  factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                       FUN=is.factor, FUN.VALUE=logical(1))
  
  if (!all(factorvars)) {
    nonfactorvars <- names(factorvars)[!factorvars]
    message("Automatically converting the following non-factors to factors: ",
            paste(nonfactorvars, collapse = ", "))
    data[nonfactorvars] <- lapply(data[nonfactorvars], factor)
  }
  
  # Get the means from the un-normed data
  datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                     na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Drop all the unused columns (these will be calculated with normed data)
  datac$sd <- NULL
  datac$se <- NULL
  datac$ci <- NULL
  
  # Norm each subject's data
  ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
  
  # This is the name of the new column
  measurevar_n <- paste(measurevar, "_norm", sep="")
  
  # Collapse the normed data - now we can treat between and within vars the same
  ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                      na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Apply correction from Morey (2008) to the standard error and confidence interval
  #  Get the product of the number of conditions of within-S variables
  nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                  FUN.VALUE=numeric(1)))
  correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )
  
  # Apply the correction factor
  ndatac$sd <- ndatac$sd * correctionFactor
  ndatac$se <- ndatac$se * correctionFactor
  ndatac$ci <- ndatac$ci * correctionFactor
  
  # Combine the un-normed means with the normed results
  merge(datac, ndatac)
}


## get within-subjects CIs for plotting
summary.avg <- summarySEwithin(data = dplyr::filter(lumi.raw.avg, ageday >= 90), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal"), withinvars = "type",
                                  idvar = "subj_id")
kable(summary.avg, caption = "Summary of Avg Looks to Eff and Ineff Actions")


summary.tp <- summarySEwithin(data = dplyr::filter(lumi.raw.tp, ageday >= 90), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal"), withinvars = c("testtype", "testpair"),
                                   idvar = "subj_id")
summary.tp
```

A.
```{r fig2a, echo = FALSE, warning = FALSE, fig.width = 18, cache = TRUE}

# avg looks to eff and ineff, grouped by experiment, with full variable info 
fig2.raw <- ggplot(data = dplyr::filter(lumi.raw.avg), aes(type, look, fill=experiment))
fig2.raw +
  geom_boxplot(outlier.colour = NA, alpha = 0.5)+
  stat_summary(fun.y = mean, alpha = 0.8, geom = "point", shape=21, size=3, position = "dodge", colour = "black") +
  ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 40)) +
  geom_point(alpha = 0.1)+
  geom_line(alpha = 0.1, aes(group = subj_id))+
  geom_errorbar(data = summary.avg, size = .5, width = 0, aes(ymin=look-ci, ymax=look+ci)) +
  facet_grid(~experiment+training+hab+goal+mitten+causal)+
  scale_x_discrete(labels = c("eff","ineff"))+
  theme_linedraw(15)+
  theme(legend.position="none", axis.title.x=element_blank())
```
B.
```{r fig2b, echo = FALSE, warning = FALSE, fig.width = 18, cache = TRUE}
# prop looks ineff, grouped by experiment, with full variable info 
fig2.prop <- ggplot(data = dplyr::filter(lumi.prop.avg), aes(testtype, look, fill=experiment))
fig2.prop + 
  geom_violin(alpha = 0.5, fill = NA, width = 0.5)+
  geom_boxplot(alpha = 0.5)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  ylab("Proportion Looking to Inefficient Reach") +
  xlab(element_blank())+
  geom_jitter(width = .05, alpha = 0.2)+
  coord_cartesian(ylim = c(0,1)) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", position = position_dodge(width = 5), width = 0) +
  geom_hline(yintercept=0.5, alpha=0.4)+
  facet_grid(~experiment+training+hab+goal+mitten+causal)+
  theme_linedraw(15)+
  theme(strip.placement = "outside") +
  theme(legend.position="none", axis.text.x = element_blank(), axis.title.x=element_blank())

```

**Figure 2.** Looking time in (A) seconds towards the efficient versus inefficient reach, and (B) proportion looking towards the inefficient reach at test across Experiments 1-5 (*n*=152) and across Experiments 1-5 in Skerry et al. (2013) (*n*=112). Labels above each panel list the experiment name (Exp. 1-5, SCS Exp. 1-5), type of motor training (none, sticky, or not.sticky mittens), type of habituation (constrained or unconstrained), goal (state.change or pick.up), whether her actions appeared to be causal (yes.causal or no.causal), and whether the actress wore a mitten (yes.mitten or no.mitten). Error bars around means indicate within-subjects 95% confidence intervals (A) and bootstrapped 95% confidence intervals (B). Individual points (B) or pairs of points (A) indicate data from a single participant. Horizontal bars within boxes indicate medians, and boxes indicate the middle 2 quartiles of data. Violin plots in (B) indicate distribution of data, area scaled proportionally to the number of observations. 

```{r fig_misc, include = FALSE, cache = TRUE}
plot.prop.tp <- ggplot(data = dplyr::filter(lumi.prop.tp), aes(testpair, look, fill=experiment))
plot.prop.tp + 
  geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  ylab("Proportion Looking to Inefficient Reach") +
  xlab(element_blank())+
  geom_point(alpha = 0.2)+
  coord_cartesian(ylim = c(0,1)) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = .1) +
  geom_hline(yintercept=0.5, alpha=0.4)+
  # stat_summary(fun.y=mean, geom="point", fill="white", shape=23, size=6)+
  facet_wrap(~experiment+training+hab+goal+mitten+causal)+
  theme_linedraw(15)+
  theme(legend.position="none", axis.text.x = element_blank(), axis.title.x=element_blank())
  
# habituation sum
hab.plot <- ggplot(data = filter(lumi.wide, paper == "LBS"), aes(experiment, total_hab, fill = experiment)) 
hab.plot + 
  geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = 0.05) +
  xlab("Experiment") + ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 500)) +
  theme_linedraw(15)+
  theme(legend.position="none")
```

```{r analysis_prep, include = FALSE, cache=TRUE}
exp1.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.1")
exp2.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.2")
exp3.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.3")
exp4.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4")
exp5.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.5")
exp45.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4" | experiment == "Exp.5")
op <- options(contrasts = c("contr.treatment", "contr.poly")) # treatment contrasts

# function for identifying influential observations, and then returning a new model without them
# INPUTS: model = model name, data = dataset, and subj = column heading for observations
# OUTPUT: model excluding influential subjects
exclude.cooks <- function(model, data, subj) {
  cooks <- cooks.distance(influence(model, subj))
  cutoff <- 4/length(unique(data$subj))
  new.model <- exclude.influence(model1.exp1, grouping = "subj_id", level=data[which(cooks > cutoff),]$subj_id)
  return(new.model)
}
```

# Results

## Experiment 1
```{r exp1, cache = TRUE}

# null model
model0.exp1 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp1.avg, REML = FALSE)

# hypothesis-driven model
model1.exp1 <- lmer(formula = loglook ~ type * hab + (1|subj_id),
               data = exp1.avg, REML = FALSE)
model1.exp1.table <- data.frame(coef(summary(model1.exp1)))

# standardized values
model1.exp1.beta <- lmer(formula = scale(loglook) ~ type * hab + (1|subj_id),
                         data = exp1.avg, REML = FALSE)

# identify and check influence of observations
model.exp1.cooks <- exclude.cooks(model1.exp1, exp1.avg, "subj_id")

# look at contrasts within each habituation condition
contrasts.exp1 <- difflsmeans(model1.exp1, test.effs="type:hab")[[1]]
names(contrasts.exp1) <- str_replace_all(names(contrasts.exp1), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp1) <- str_replace_all(names(contrasts.exp1), '-', '')
```


In Experiment 1 (N=`r length(unique(exp1.avg$subj_id))`; `r length(unique(exp1.avg$subj_id))/2` per condition), we asked whether 3-month-old infants expect a person to reach out and cause an object to change state efficiently. Half of infants were randomly assigned to habituate to a person who reached over a barrier (H1) and appeared to cause an object to light up by touching it, and then tested on efficient and inefficient reaches without the barrier (T1). The other half of infants habituated to the same reaches except that the barrier was located beyond the goal object, out of the person's way (H2), and viewed the same test events Infants responded differently to the test events across these two habituation conditions, B=`r model1.exp1.table$Estimate[4]`, p=`r model1.exp1.table$Pr...t..[4]`, mixed effects model with fixed interaction between habituation and test event and random intercept for participants. We found that infants looked longer at the inefficient action (M=`r summary.avg$look[2]`s, SD=`r summary.avg$sd[2]`) than the efficient action (M=`r summary.avg$look[1]`s, SD=`r summary.avg$sd[1]`), B=`r contrasts.exp1$Estimate[1]`, p=`r contrasts.exp1$pvalue[1]`. And critically, this looking preference cannot be attributed to low-level preferences for the curvilinear reach, because infants who were randomly assigned to habituate to identical videos without the barrier in the way (H2) looked equally to the inefficient (M=`r summary.avg$look[4]`s, SD=`r summary.avg$sd[4]`) and efficient (M=`r summary.avg$look[3]`s, SD=`r summary.avg$sd[3]`)  actions, p=`r contrasts.exp1$pvalue[6]`. 

## Experiment 2
```{r exp2, cache = TRUE}

# null model
model0.exp2 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp2.avg, REML = FALSE)

# hypothesis-driven model
model1.exp2 <- lmer(formula = loglook ~ type + (1|subj_id),
               data = exp2.avg, REML = FALSE)
model1.exp2.table <- data.frame(coef(summary(model1.exp2)))

# standardized values
model1.exp1.beta <- lmer(formula = scale(loglook) ~ type + (1|subj_id),
                         data = exp2.avg, REML = FALSE)

# identify and check influence of observations
# model.exp2.cooks <- exclude.cooks(model1.exp2, exp2.avg, "subj_id")

# comparing results to Exp 1
causality12 <- lumi.raw.avg %>%
  filter(experiment == 'Exp.1' | experiment == "Exp.2") %>%
  filter(hab == "constrained")

model1.exp12 <- lmer(formula = loglook ~ type * causal + (1|subj_id) + (1|experiment),
                     data = causality12, REML=FALSE)
model1.exp12.table <- data.frame(coef(summary(model1.exp12)))

# look at contrasts within each caual condition
contrasts.exp12 <- difflsmeans(model1.exp12, test.effs="type:causal")[[1]]
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), '-', '')
```

In Experiment 2 (N=`r length(unique(exp2.avg$subj_id))`), we asked whether infants’ sensitivity to the efficiency of this action depends their construal of the person as a causal agent (an agent contacting an object, thereby changing its state) or on lower-level scene features (an agent reaching towards a toy that lights up), by manipulating the spatiotemporal contingency of this action. In Experiment 2, pre-registered at xxxxxxx, infants were habituated to videos identical to H1, except that the person’s hand stopped 50 pixels away from the object, and the object changed state after a 0.5 delay (H3). At test, the person reached efficiently or inefficiently in the absence of the barrier with the same spatiotemporal gap (T2). This manipulation was inspired by past studies of causal perception (cite, cite), and asks whether infants' analysis of the causal structure of an action is critical to their understanding of this action as intentional. We found that infants looked equally between the efficient (M=`r summary.avg$look[5]`s, SD=`r summary.avg$sd[5]`) and inefficient (M=`r summary.avg$look[6]`s, SD=`r summary.avg$sd[6]`) reach (T2), B=`r model1.exp2.table$Estimate[2]`, p=`r model1.exp2.table$Pr...t..[2]`, mixed effects model with trial type as fixed effect and participants as a random intercept, a result that differed from infants’ responses to causally contingent videos, B=`r model1.exp12.table$Estimate[4]`, p=`r model1.exp12.table$Pr...t..[4]`, mixed effects model with fixed interaction between causality and trial type.

## Experiment 3
```{r exp3, cache = TRUE}

# null model
model0.exp3 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp3.avg, REML = FALSE)

model1.exp3 <- lmer(formula = loglook ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)
model1.exp3.table <- data.frame(coef(summary(model1.exp3)))

# standardized values
model1.exp3.beta <- lmer(formula = scale(loglook) ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)

# identify and check influence of observations
# model.exp3.cooks <- exclude.cooks(model1.exp3, exp3.avg, "subj_id")

# look at contrasts within each caual condition
contrasts.exp3 <- difflsmeans(model1.exp3, test.effs="type:causal")[[1]]
names(contrasts.exp3) <- str_replace_all(names(contrasts.exp3), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp3) <- str_replace_all(names(contrasts.exp3), '-', '')
```

Experiment 3 (N=`r length(unique(exp3.avg$subj_id))`; `r length(unique(exp3.avg$subj_id))/2` per condition) attempts to replicates the findings from Experiments 1 and 2 by asking whether infants only expect causally effective reaches to be efficient, relative to the same actions that are not spatiotemporally contingent. We randomly assigned infants to H1 and T1, or H2 and T2, which enables us to stringently compare infants' responses to the test displays as a function of causal information. Infants again looked to the events differently depending on whether the events were causal, B=`r model1.exp3.table$Estimate[4]`, p=`r model1.exp3.table$Pr...t..[4]`, mixed effects model with fixed interaction of causality and test event. Like in Experiment 1, infants looked longer at the inefficient reach (M=`r summary.avg$look[10]`s, SD=`r summary.avg$sd[10]`) versus the efficient reach (M=`r summary.avg$look[9]`s, SD=`r summary.avg$sd[9]`) when the person’s actions were causally effective, B=`r contrasts.exp3$Estimate[6]`, p=`r contrasts.exp3$pvalue[6]`, and as in Experiment 3, infants looked equally to the inefficient (M=`r summary.avg$look[8]`s, SD=`r summary.avg$sd[8]`) and efficient (M=`r summary.avg$look[7]`s, SD=`r summary.avg$sd[7]`) reach when her actions were causally noncontingent, B=`r contrasts.exp3$Estimate[1]`, p=`r contrasts.exp3$pvalue[1]`. Together, Experiments 1-3 show that pre-reaching infants apply the principle of efficiency (Gergely & Csibra, 2003) to reaching actions that they themselves have never experienced, and that they only apply this principle to actions that appear to cause changes in the world.

## Experiments 4 and 5
```{r exp45, cache = TRUE}
# null model
model0.exp45 <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp45.avg, REML = FALSE)

model1.exp45 <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)
model1.exp45.table <- data.frame(coef(summary(model1.exp3)))

# standardized values
model1.exp45.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)

# identify and check influence of observations
# model1.exp45.cooks <- exclude.cooks(model1.exp45, exp45.avg, "subj_id")

# look at contrasts within each caual condition
contrasts.exp45 <- difflsmeans(model1.exp45, test.effs="type:mitten")[[1]]
names(contrasts.exp45) <- str_replace_all(names(contrasts.exp45), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp45) <- str_replace_all(names(contrasts.exp45), '-', '')

```

```{r exp5.scs, cache = TRUE}
exp5.scs <- lumi.raw.avg %>% filter(experiment == "Exp.5" | experiment == "SCS.Exp.3")

# null model
model0.exp5.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp5.scs, REML = FALSE)

model1.exp5.scs <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)
model1.exp5.scs.table <- data.frame(coef(summary(model1.exp5.scs)))

# standardized values
model1.exp5.scs.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)

# identify and check influence of observations
model1.exp4.scs.cooks <- exclude.cooks(model1.exp5.scs, exp45.scs, "subj_id")

# look at contrasts within each caual condition
contrasts.exp5.scs <- difflsmeans(model1.exp5.scs, test.effs="type:mitten")[[1]]
names(contrasts.exp5.scs) <- str_replace_all(names(contrasts.exp5.scs), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp5.scs) <- str_replace_all(names(contrasts.exp5.scs), '-', '')

```

```{r exp4.scs, cache = TRUE}
exp4.scs <- lumi.raw.avg %>% filter(experiment == "Exp.4" | experiment == "SCS.Exp.3")

# null model
model0.exp4.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp4.scs, REML = FALSE)

model1.exp4.scs <- lmer(formula = loglook ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)
model1.exp4.scs.table <- data.frame(coef(summary(model1.exp4.scs)))

# standardized values
model1.exp4.scs.beta <- lmer(formula = scale(loglook) ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)

# identify and check influence of observations
model1.exp4.scs.cooks <- exclude.cooks(model1.exp4.scs, exp4.scs, "subj_id")

# look at contrasts within each caual condition
contrasts.exp4.scs <- difflsmeans(model1.exp4.scs, test.effs="type:experiment")[[1]]
names(contrasts.exp4.scs) <- str_replace_all(names(contrasts.exp4.scs), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp4.scs) <- str_replace_all(names(contrasts.exp4.scs), '-', '')

```

Why do infants succeed here without motor training, and fail in Skerry et al. (2013)? One possibility is that pre-reaching infants struggle to understand the causal structure of reaching for and retrieving an object without the relevant motor experience. Another possibility is that pre-reaching infants do not interpret the reach of a mittened hand, one that looks different from most hands they see, as intentional without the relevant experience of observing and experiencing their own mittened hands act causally during training (see WOODWARD GLOVE). To test for this second possibility, we ran two additional experiments. In Experiment 4, infants were habituated and tested on events very similar to those from Skerry (H4, T3), where a person reaches for and picks up an object while wearing a white mitten. In Experiment 5, infants saw similar videos except that the person reached with a bare hand (H5, T4).

We found that infants looked marginally longer at the inefficient (M, SD) vs efficient (M, SD) reach when a bare hand was reaching, STATS, and did not distinguish these two actions when a mittened hand was reaching, STATS. However, these two patterns of looking did not differ from each other, STATS.

We also compared these results against those from Skerry et al. (2013), Experiment 3, and found that the results from Experiment 5 (no mitten) differed from those in SCS Experiment 3 (mitten), STATS. However, these results are difficult to interpret, as paper is confounded with mitten in this analysis. Although the results from Experiment 4 (mitten) do not differ from those in SCS Experiment 3 (mitten), STATS, we do not have sufficient evidence to assess the claim that manipulating whether the person wears a mitten causes infants to assess her actions differently. Thus, the effect of surface properties on infants’ action understanding is yet to be fully explored. Looking across Experiment 1-5, the key difference between the state change events we used in the present experiments, and the pickup events used in Skerry et al (2013), differ in their causal transparency: Untrained infants who do not know how to reach for and grasp objects may nevertheless possess the intuition that causal agents behave efficiently.

## Meta-analysis across all experiments

Across Experiments 1-5, we found that pre-reaching infants apply expectations of efficient action to agents that pursue the goal of causing a change in an object. To assess the unique effects of our experimental manipulations, and to compare our data directly to those from Skerry et al. (2013), we performed an exploratory meta-analysis over the 12 conditions (total N=`r length(unique(lumi.wide$subj_id))`) from these two papers. Our analytic approach allows us to assess the independent effects of a wide array of manipulations, including variations in motor training, habituation, goal, and surface properties, on infants’ expectations about efficient reaching, while controlling participant variables like age, sex, and counterbalanced variables like the order of test events. For ease of interpretation, we use average proportion looking to the inefficient action in this analysis, following Skerry et al. (2013).

```{r meta}
# set contrasts for analysis - compare effects against the grand mean
op <- options(contrasts = c("contr.sum", "contr.poly"))

# full exploratory model
model1.all <- lmer(formula = prop.ineff.all ~ training + hab + goal + mitten + causal + (1+first.test|experiment) + (1|ageday) + (1|sex) + (1|paper),
                   data = lumi.wide)
model1.all.table <- data.frame(coef(summary(model1.all)))
plot(allEffects(model1.all),
     main = NA,
     ylim=c(0.39,0.61),
     cex.lab = 4,
     cex.axis = 4,
     cex = .7)
# address influential observations
# model1.all.cooks <- exclude.cooks(model1.all, lumi.wide, "subj_id")
# kable(model1.all.table)
pander(model1.all.table)

```
We found that infants’ expectations were made stronger when the action being tested was causally contingent, STATS, and when the person reason behaved rationally, STATS. We also found a marginally significant effect of action type, where infants had stronger expectations about state change than pick-up actions, STATS. In contrast, we found no unique contribution of motor training, or of the surface properties of the agent. This analysis is consistent with our general interpretation infants expect any intentional, rational agent to reach efficiently so long as the causal mechanism of their action is clear. 

<!-- ## Power analyses------- -->

<!-- model.orig <- lmer(loglook ~ type + (1|subj_id), -->
<!--                    data = dplyr::filter(exp1.avg, hab == "constrained" & ageday > 90)) -->
<!-- summary(model.orig) -->

<!-- exp1.sim <- powerCurve(extend(model.orig, along="subj_id", n=400), -->
<!--                        along="subj_id", breaks = c(20, 25, 30, 35, 40), alpha = .05, seed = 123) -->
<!-- plot(exp1.sim) -->
<!-- print(exp1.sim) -->


