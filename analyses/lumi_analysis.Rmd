
---
title: "Pre-reaching infants expect causal agents to reach efficiently"
author: "Shari Liu"
date: "July 31 2018"
output: html_document
---

# Tables and Figures

**Table 1.** Summary of conditions, design, and sample sizes of Experiments 1-5, and SCS Experiments 1-5. Conditions listed under a single experiment (e.g. Exp 1 and 3) included random assignment to condition. For stimuli, see Fig 1. * indicates direct replication.

Experiment | N | Training |  Goal | Habituation | Causal | Mitten | Stimuli
---------- | - | ---------| ----- | ----------- | ------ | ------ | -------
1 | 20 | none | state change | constrained | yes | yes | H1, T1
1 | 20 | none | state change | unconstrained | yes | yes | H2, T1
2 | 20 | none | state change | constrained | no | yes | H3, T2
3* | 26 | none |  state change | constrained | yes | yes | H1, T1
3* | 26 | none | state change | constrained | no | yes | H3, T2
4 | 20 | none | pick up | constrained | yes | yes | H4, T3
5 | 20 | none | pick up | constrained | yes | no | H5, T4
SCS 1 | 20 | effective | pick up | constrained | yes | yes |
SCS 2 | 20 | ineffective | pick up | constrained | yes | yes |
SCS 3 | 20 | none | pick up | constrained | yes | yes |
SCS 4* | 26 | effective | pick up | constrained | yes | yes |
SCS 5 | 26 | effective | pick up |unconstrained | yes | yes |

***

![**Figure 1.** Still frames from videos shown to participants in Experiments 1-5, including stimuli from habituation (H1-H5) and test (T1-T4). In each video, a person reached for and caused a change in an object (H1-H3, T1-T2), or picked up the object (H4-H5, T3-T4), over a barrier (H1- H2, H4-H5) or over empty space (H2, T1-T4), and either acted on the object by contacting it (H1-H2, H4-H5, T1, T3-T4) or produced the same effect from a distance of 50 pixels, after a 0.5s delay (H3, T2). During test (T1-T4), the person either reached directly for the object (T1-T4, left panel), or in a curvilinear fashion (T1-T4, right panel).](/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/fig1.jpeg)

***

```{r setup, include = FALSE}
knitr::opts_chunk$set(comment = "##", echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, include=FALSE, dependson="lumi_wide")
options(scipen = 0, digits = 3)
## load required packages
ipak <- function (pkg) {
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}


packages <- c("tidyverse", "Hmisc", "lattice", "multcomp", "lsmeans", "schoRsch", "influence.ME", "devtools", "skimr", "simr", "lme4", "sjPlot", "effects", "lmerTest", "compute.es", "pwr", "stringr", "irr")

ipak(packages)

```

```{r import}

lumi.wide <- read.csv("/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/lumi_data_deid.csv", header = TRUE) # change to your local directory
lumi.rel <- read.csv("/Users/shariliu/Documents/HarvardLDS/Studies/LUMI/github/analyses/lumi_reliability.csv", header=TRUE)

str(lumi.wide)
```

```{r prep_data}
# convert to long format
lumi.long <- gather(lumi.wide, type, look, ineff.1:avg.eff)
str(lumi.long)
lumi.long$type <- factor(lumi.long$type)
lumi.long$loglook <- log(lumi.long$look)
lumi.long$testpair <- NA
lumi.long$testtype <- NA

# assign test pair and type info to data from individual test trials
for (i in 1:nrow(lumi.long)) {
  if (lumi.long$type[i] == "ineff.1" | lumi.long$type[i] == "prop.ineff1") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "ineff.2" | lumi.long$type[i] == "prop.ineff2") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "ineff.3" | lumi.long$type[i] == "prop.ineff3") {
    lumi.long$testtype[i] <- "inefficient"
    lumi.long$testpair[i] <- "third"
  }
  else if (lumi.long$type[i] == "eff.1") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "first"
  }
  else if (lumi.long$type[i] == "eff.2") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "second"
  }
  else if (lumi.long$type[i] == "eff.3") {
    lumi.long$testtype[i] <- "efficient"
    lumi.long$testpair[i] <- "third"
  }
}


# set baseline levels of all categorical predictors for analyses later on
lumi.long$testtype <- factor(lumi.long$testtype)
lumi.long$testtype <- relevel(lumi.long$testtype, ref = "inefficient")
lumi.long$testpair <- factor(lumi.long$testpair)
lumi.long$testpair <- relevel(lumi.long$testpair, ref = "first")
lumi.wide$first.test <- relevel(lumi.wide$first.test, ref = "efficient")
lumi.wide$goal <- relevel(lumi.wide$goal, ref = "pick.up")
lumi.wide$hab <- relevel(lumi.wide$hab, ref = "unconstrained")
lumi.wide$mitten <- relevel(lumi.wide$mitten, ref = "no.mitten")
lumi.wide$training <- relevel(lumi.wide$training, ref = "no.training")
lumi.wide$causal <- relevel(lumi.wide$causal, ref = "no.causal")
lumi.wide$sex <- relevel(lumi.wide$sex, ref = "m")
lumi.wide$habbed <- factor(lumi.wide$habbed)
lumi.wide$habbed <- relevel(lumi.wide$habbed, ref = "0")
lumi.wide$pref <- relevel(lumi.wide$pref, ref = "eff")

# section data based on dv
lumi.prop.avg <- filter(lumi.long, type == "prop.ineff.all")
lumi.raw.avg <- filter(lumi.long, type == "avg.eff" | type == "avg.ineff")
lumi.prop.tp <- filter(lumi.long, type == "prop.ineff1" | type == "prop.ineff2" | type == "prop.ineff3")
lumi.raw.tp <- filter(lumi.long, type == "ineff.1" | type == "ineff.2" | type == "ineff.3" | type == "eff.1" |type == "eff.2"| type == "eff.3")
```


```{r within_variance}
## Retrieved from : http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#error-bars-for-within-subjects-variables
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the "mean" column    
  datac <- plyr::rename(datac, c("mean" = measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}
## Norms the data within specified groups in a data frame; it normalizes each
## subject (identified by idvar) so that they have the same mean, within each group
## specified by betweenvars.
##   data: a data frame.
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   na.rm: a boolean that indicates whether to ignore NA's
normDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
  library(plyr)
  
  # Measure var on left, idvar + between vars on right of formula.
  data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,
                         .fun = function(xx, col, na.rm) {
                           c(subjMean = mean(xx[,col], na.rm=na.rm))
                         },
                         measurevar,
                         na.rm
  )
  
  # Put the subject means with original data
  data <- merge(data, data.subjMean)
  
  # Get the normalized data in a new column
  measureNormedVar <- paste(measurevar, "_norm", sep="")
  data[,measureNormedVar] <- data[,measurevar] - data[,"subjMean"] +
    mean(data[,measurevar], na.rm=na.rm)
  
  # Remove this subject mean column
  data$subjMean <- NULL
  
  return(data)
}

## Summarizes data, handling within-subjects variables by removing inter-subject variability.
## It will still work if there are no within-S variables.
## Gives count, un-normed mean, normed mean (with same between-group mean),
##   standard deviation, standard error of the mean, and confidence interval.
## If there are within-subject variables, calculate adjusted values using method from Morey (2008).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   betweenvars: a vector containing names of columns that are between-subjects variables
##   withinvars: a vector containing names of columns that are within-subjects variables
##   idvar: the name of a column that identifies each subject (or matched subjects)
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,
                            idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
  
  # Ensure that the betweenvars and withinvars are factors
  factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                       FUN=is.factor, FUN.VALUE=logical(1))
  
  if (!all(factorvars)) {
    nonfactorvars <- names(factorvars)[!factorvars]
    message("Automatically converting the following non-factors to factors: ",
            paste(nonfactorvars, collapse = ", "))
    data[nonfactorvars] <- lapply(data[nonfactorvars], factor)
  }
  
  # Get the means from the un-normed data
  datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                     na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Drop all the unused columns (these will be calculated with normed data)
  datac$sd <- NULL
  datac$se <- NULL
  datac$ci <- NULL
  
  # Norm each subject's data
  ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
  
  # This is the name of the new column
  measurevar_n <- paste(measurevar, "_norm", sep="")
  
  # Collapse the normed data - now we can treat between and within vars the same
  ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                      na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
  
  # Apply correction from Morey (2008) to the standard error and confidence interval
  #  Get the product of the number of conditions of within-S variables
  nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                  FUN.VALUE=numeric(1)))
  correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )
  
  # Apply the correction factor
  ndatac$sd <- ndatac$sd * correctionFactor
  ndatac$se <- ndatac$se * correctionFactor
  ndatac$ci <- ndatac$ci * correctionFactor
  
  # Combine the un-normed means with the normed results
  merge(datac, ndatac)
}


## get within-subjects CIs for plotting
summary.avg <- summarySEwithin(data = dplyr::filter(lumi.raw.avg), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = "type",
                                  idvar = "subj_id")
kable(summary.avg, caption = "Summary of Avg Looks to Eff and Ineff Actions")


summary.tp <- summarySEwithin(data = dplyr::filter(lumi.raw.tp), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = c("testtype", "testpair"),
                                   idvar = "subj_id")
summary.tp

prop.tp <- summarySEwithin(data = dplyr::filter(lumi.prop.tp), measurevar = "look", betweenvars = c("experiment", "training", "hab","goal","mitten","causal", "paper"), withinvars = "testpair",
                                   idvar = "subj_id")
prop.tp


```

A.
```{r fig2a, fig.width = 18, include=TRUE}

# avg looks to eff and ineff, grouped by experiment, with full variable info 
fig2.raw <- ggplot(data = dplyr::filter(lumi.raw.avg), aes(type, look, fill=experiment))
fig2.raw +
  geom_boxplot(outlier.colour = NA, alpha = 0.5)+
  stat_summary(fun.y = mean, alpha = 0.8, geom = "point", shape=21, size=3, position = "dodge", colour = "black") +
  ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 40)) +
  geom_point(alpha = 0.1)+
  geom_line(alpha = 0.1, aes(group = subj_id))+
  geom_errorbar(data = summary.avg, size = .5, width = 0, aes(ymin=look-ci, ymax=look+ci)) +
  facet_grid(~experiment+training+hab+goal+mitten+causal)+
  scale_x_discrete(labels = c("eff","ineff"))+
  theme_linedraw(15)+
  theme(legend.position="none", axis.title.x=element_blank())
```
B.
```{r fig2b, fig.width = 18, , include=TRUE}
# prop looks ineff, grouped by experiment, with full variable info 
fig2.prop <- ggplot(data = dplyr::filter(lumi.prop.avg), aes(testtype, look, fill=experiment))
fig2.prop + 
  geom_violin(alpha = 0.5, fill = NA, width = 0.5)+
  geom_boxplot(alpha = 0.5)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  ylab("Proportion Looking to Inefficient Reach") +
  xlab(element_blank())+
  geom_jitter(width = .05, alpha = 0.2)+
  coord_cartesian(ylim = c(0,1)) +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", position = position_dodge(width = 5), width = 0) +
  geom_hline(yintercept=0.5, alpha=0.4)+
  facet_grid(~experiment+training+hab+goal+mitten+causal)+
  theme_linedraw(15)+
  theme(strip.placement = "outside") +
  theme(legend.position="none", axis.text.x = element_blank(), axis.title.x=element_blank())

```

**Figure 2.** Looking time in (A) seconds towards the efficient versus inefficient reach, and (B) proportion looking towards the inefficient reach at test across Experiments 1-5 (*n*=152) and across Experiments 1-5 in Skerry et al. (2013) (*n*=112). Labels above each panel list the experiment name (Exp. 1-5, SCS Exp. 1-5), type of motor training (none, sticky, or not.sticky mittens), type of habituation (constrained or unconstrained), goal (state.change or pick.up), whether her actions appeared to be causal (yes.causal or no.causal), and whether the actress wore a mitten (yes.mitten or no.mitten). Error bars around means indicate within-subjects 95% confidence intervals (A) and bootstrapped 95% confidence intervals (B). Individual points (B) or pairs of points (A) indicate data from a single participant. Horizontal bars within boxes indicate medians, and boxes indicate the middle 2 quartiles of data. Violin plots in (B) indicate distribution of data, area scaled proportionally to the number of observations. 

***

```{r figS1, fig.width = 7, include=TRUE}
# is a lognormal transformation justified given the distribution of looks?
fig.S1 <- ggplot(data = dplyr::filter(lumi.raw.avg), aes(look, fill=experiment, colour = experiment))
fig.S1 +
  geom_density(alpha = 0.5)+
  # geom_text(aes(experiment))+
  theme_linedraw(15)+
  xlab("Looking Time (s)")

normal.ll <- fitdistr(lumi.raw.avg$look, "normal")$loglik
lognormal.ll <- fitdistr(lumi.raw.avg$look, "lognormal")$loglik
```

**Figure S1.** Density plot of looking times during test across Experiments 1-5, and Experiments 1-5 from Skerry et al. (2013) (N=`r length(unique(lumi.wide$subj_id))`). Maximum-likelihood fitting revealed that the lognormal distribution (log likelihood=`r lognormal.ll`) provides a better fit to these data than the normal distribution (log likelihood=`r normal.ll`).

***

```{r figS2, fig.width = 7, include=TRUE}
# plot.prop.tp <- ggplot(data = dplyr::filter(lumi.prop.tp), aes(testpair, look, fill=experiment))
# plot.prop.tp + 
#   geom_violin(alpha = 0.5, fill = NA)+
#   geom_boxplot(alpha = 0.5, width = 0.5)+
#   stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
#   ylab("Proportion Looking to Inefficient Reach") +
#   xlab(element_blank())+
#   geom_point(alpha = 0.2)+
#   coord_cartesian(ylim = c(0,1)) +
#   geom_errorbar(data = prop.tp, size = .5, width = 0, aes(ymin=look-ci, ymax=look+ci)) +
#   geom_hline(yintercept=0.5, alpha=0.4)+
#   facet_grid(~experiment+training+hab+goal+mitten+causal)+
#   theme_linedraw(10)+
#   theme(legend.position="none")
#   
# habituation sum
hab.plot <- ggplot(data = filter(lumi.wide, paper == "LBS"), aes(experiment, total_hab, fill = experiment))
hab.plot + 
  geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  geom_jitter(width = .05, alpha = 0.2)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = 0.05) +
  xlab("Experiment") + ylab("Looking Time (s)") +
  coord_cartesian(ylim = c(0, 500)) +
  theme_linedraw(15)+
  theme(legend.position="none")
```

**Figure S2.** Total looking time in seconds during habituation across Experiment 1-5. Error bars around means indicate bootstrapped 95% confidence intervals. Individual points indicate data from a single participant. Horizontal bars within boxes indicate medians, and boxes indicate the middle 2 quartiles of data. Violin plots in indicate distribution of data, area scaled proportionally to the number of observations. 

***

```{r analysis_prep}
exp1.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.1")
exp2.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.2")
exp3.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.3")
exp4.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4")
exp5.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.5")
exp45.avg <-dplyr::filter(lumi.raw.avg, experiment == "Exp.4" | experiment == "Exp.5")
op <- options(contrasts = c("contr.treatment", "contr.poly")) # treatment contrasts

# function for identifying influential observations, and then returning a new model without them
# INPUTS: model = model name, data = dataset, and subj = column heading for observations
# OUTPUT: model excluding influential subjects
exclude.cooks <- function(model, data, subj) {
  cooks <- cooks.distance(influence(model, subj))
  cutoff <- 4/length(unique(data$subj))
  new.model <- exclude.influence(model, grouping = subj, level=data[which(cooks > cutoff),]$subj)
  return(new.model)
}

# function that computes CIs and returns them in df
gen.ci <- function(model) {
  df <- data.frame(confint(model))
  names(df) <- c("lower", "upper")
  return(df)
}

# function that converts model summary to df
gen.m <- function(model) {
  df <- data.frame(coef(summary(model)))
  names(df) <- c("est", "se", "df", "t", "p")
  return(df)
}

# function that returns age info and number of females in a dataset
ages <- function(longdata) {
  longdata %>% summarize(mean = mean(ageday), min=range(ageday)[1], max=range(ageday)[2], f=sum(sex=="f")/2)
}
```

# Results

## Reliability
```{r reliability}
exp1.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.1")$newlook, filter(lumi.rel, experiment == "Exp.1")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp2.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.2")$newlook, filter(lumi.rel, experiment == "Exp.2")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp3.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.3")$newlook, filter(lumi.rel, experiment == "Exp.3")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp4.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.4")$newlook, filter(lumi.rel, experiment == "Exp.4")$look.orig), model = "twoway", type = "agreement", unit = "single")
exp5.rel <- icc(cbind(filter(lumi.rel, experiment == "Exp.5")$newlook, filter(lumi.rel, experiment == "Exp.5")$look.orig), model = "twoway", type = "agreement", unit = "single")

lumi.rel <- lumi.rel %>%
  mutate(big = gap > 3)

table(lumi.rel$big)
  
```
```{r rel_plot, include=TRUE}
relplot <- ggplot(data = lumi.rel, aes(experiment, gap, fill = experiment))
relplot + 
  # geom_violin(alpha = 0.5, fill = NA)+
  geom_boxplot(alpha = 0.5, width = 0.5)+
  geom_jitter(width = .05, alpha = 0.2)+
  stat_summary(fun.y = mean, geom = "point", shape =21, size=3, position = "dodge", colour = "black") +
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", colour="black", size = .6, position = position_dodge(width = .9), width = 0.05) +
  xlab("Experiment") + ylab("Discrepancy (New - Original) (s)") +
  theme_linedraw(15)+
  theme(legend.position="none")  
```

**Figure S3.** Discrepancy between original and new coding of looking times during test trials in seconds. 

***

To assess reliability, 50% of test trials from participants across Experiments 1-5 (`r length(unique(lumi.wide$subj_id))/2` participants, `r nrow(lumi.rel)` trials) were randomly selected and coded by additional researchers who were unaware of experimental condition, and test trial order. The intraclass correlation coefficient (ICC) between the original data, and this newly coded data, was `r exp1.rel$value` [`r exp1.rel$lbound`, `r exp1.rel$ubound`], `r exp2.rel$value` [`r exp2.rel$lbound`, `r exp2.rel$ubound`], `r exp3.rel$value` [`r exp3.rel$lbound`, `r exp3.rel$ubound`], `r exp4.rel$value` [`r exp4.rel$lbound`, `r exp4.rel$ubound`], `r exp5.rel$value` [`r exp5.rel$lbound`, `r exp5.rel$ubound`], for Experiments 1 through 5, respectively.

## Exclusion info
Experiment | Fussiness | Inattentiveness | Caregiver Interference | Experimenter/Coding Error | Technical Failure | Total 
---------- | --------- | --------------- | ---------------------- | ------------------------- | ----------------- | -----
Exp.1 | 9 | 5 | 1 | 6 | 3 | 24
Exp.2 | 0 | 0 | 0 | 2 | 0 | 2
Exp.3 | 6 | 0 | 0 | 2 | 0 | 8
Exp.4 | 7 | 0 | 0 | 2 | 0 | 7
Exp.5 | 6 | 0 | 0 | 1 | 2 | 9

***

## Experiment 1
```{r exp1}
# participant info
exp1.info <- ages(exp1.avg)

# null model
model0.exp1 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp1.avg, REML = FALSE)

# hypothesis-driven model
model1.exp1 <- lmer(formula = loglook ~ type * hab + (1|subj_id),
               data = exp1.avg, REML = FALSE)
model1.exp1.table <- gen.m(model1.exp1)
model1.exp1.ci <- gen.ci(model1.exp1)

# standardized values
model1.exp1.beta <- lmer(formula = scale(loglook) ~ type * hab + (1|subj_id),
                         data = exp1.avg, REML = FALSE)
model1.exp1.beta.table <- gen.m(model1.exp1.beta)

# identify and check influence of observations
model.exp1.cooks <- exclude.cooks(model1.exp1, exp1.avg, "subj_id")

# look at contrasts within each habituation condition
contrasts.exp1 <- difflsmeans(model1.exp1, test.effs="type:hab")[[1]]
names(contrasts.exp1) <- str_replace_all(names(contrasts.exp1), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp1) <- str_replace_all(names(contrasts.exp1), '-', '')

contrasts.exp1.beta <- difflsmeans(model1.exp1.beta, test.effs="type:hab")[[1]]
names(contrasts.exp1.beta) <- str_replace_all(names(contrasts.exp1.beta), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp1.beta) <- str_replace_all(names(contrasts.exp1.beta), '-', '')
```


In Experiment 1 (N=`r length(unique(exp1.avg$subj_id))`; `r length(unique(exp1.avg$subj_id))/2` per condition), we asked whether 3-month-old infants (M=`r exp1.info$mean` days, range=`r exp1.info$min`-`r exp1.info$max`, `r exp1.info$f` female) expect a person to reach out and cause an object to change state efficiently. Half of infants were randomly assigned to habituate to a person who reached over a barrier (H1) and appeared to cause an object to light up by touching it, and then tested on efficient and inefficient reaches without the barrier (T1). The other half of infants habituated to the same reaches except that the barrier was located beyond the goal object, out of the person's way (H2), and viewed the same test events Infants responded differently to the test events across these two habituation conditions, [`r model1.exp1.ci$lower[6]`, `r model1.exp1.ci$upper[6]`], B=`r model1.exp1.table$est[4]`, ß=`r model1.exp1.beta.table$est[4]`, p=`r model1.exp1.table$p[4]`, mixed effects model with fixed interaction between habituation and test event and random intercept for participants. We found that infants looked longer at the inefficient action (M=`r summary.avg$look[2]`s, SD=`r summary.avg$sd[2]`) than the efficient action (M=`r summary.avg$look[1]`s, SD=`r summary.avg$sd[1]`), [`r contrasts.exp1$LowerCI[1]`, `r contrasts.exp1$UpperCI[1]`], B=`r contrasts.exp1$Estimate[1]`, ß=`r contrasts.exp1.beta$Estimate[1]`, p=`r contrasts.exp1$pvalue[1]`. And critically, this looking preference cannot be attributed to low-level preferences for the curvilinear reach, because infants who were randomly assigned to habituate to identical videos without the barrier in the way (H2) looked equally to the inefficient (M=`r summary.avg$look[4]`s, SD=`r summary.avg$sd[4]`) and efficient (M=`r summary.avg$look[3]`s, SD=`r summary.avg$sd[3]`) actions, [`r contrasts.exp1$LowerCI[6]`, `r contrasts.exp1$UpperCI[6]`], B=`r contrasts.exp1$Estimate[6]`, ß=`r contrasts.exp1.beta$Estimate[6]`, p=`r contrasts.exp1$pvalue[6]`. 

## Experiment 2
```{r exp2}
# participant info
exp2.info <- ages(exp2.avg)

# null model
model0.exp2 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp2.avg, REML = FALSE)

# hypothesis-driven model
model1.exp2 <- lmer(formula = loglook ~ type + (1|subj_id),
               data = exp2.avg, REML = FALSE)
model1.exp2.table <- data.frame(coef(summary(model1.exp2)))

# standardized values
model1.exp1.beta <- lmer(formula = scale(loglook) ~ type + (1|subj_id),
                         data = exp2.avg, REML = FALSE)

# identify and check influence of observations
# model.exp2.cooks <- exclude.cooks(model1.exp2, exp2.avg, "subj_id")

# comparing results to Exp 1
causality12 <- lumi.raw.avg %>%
  filter(experiment == 'Exp.1' | experiment == "Exp.2") %>%
  filter(hab == "constrained")

model1.exp12 <- lmer(formula = loglook ~ type * causal + (1|subj_id) + (1|experiment),
                     data = causality12, REML=FALSE)
model1.exp12.table <- data.frame(coef(summary(model1.exp12)))

# look at contrasts within each caual condition
contrasts.exp12 <- difflsmeans(model1.exp12, test.effs="type:causal")[[1]]
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp12) <- str_replace_all(names(contrasts.exp12), '-', '')
```

In Experiment 2 (N=`r length(unique(exp2.avg$subj_id))`), we asked whether infants’ sensitivity to the efficiency of this action depends their construal of the person as a causal agent (an agent contacting an object, thereby changing its state) or on lower-level scene features (an agent reaching towards a toy that lights up), by manipulating the spatiotemporal contingency of this action. In Experiment 2, pre-registered at https://osf.io/a5byn/, infants (M=`r exp2.info$mean` days, range=`r exp2.info$min`-`r exp2.info$max`, `r exp2.info$f` female) were habituated to videos identical to H1, except that the person’s hand stopped 50 pixels away from the object, and the object changed state after a 0.5 delay (H3). At test, the person reached efficiently or inefficiently in the absence of the barrier with the same spatiotemporal gap (T2). This manipulation was inspired by past studies of causal perception (cite, cite), and asks whether infants' analysis of the causal structure of an action is critical to their understanding of this action as intentional. We found that infants looked equally between the efficient (M=`r summary.avg$look[5]`s, SD=`r summary.avg$sd[5]`) and inefficient (M=`r summary.avg$look[6]`s, SD=`r summary.avg$sd[6]`) reach (T2), B=`r model1.exp2.table$Estimate[2]`, p=`r model1.exp2.table$Pr...t..[2]`, mixed effects model with trial type as fixed effect and participants as a random intercept, a result that differed from infants’ responses to causally contingent videos, B=`r model1.exp12.table$Estimate[4]`, p=`r model1.exp12.table$Pr...t..[4]`, mixed effects model with fixed interaction between causality and trial type.

## Experiment 3
```{r exp3}
# participant info
exp3.info <- ages(exp3.avg)

# null model
model0.exp3 <- lmer(formula = loglook ~ 1 + (1|subj_id),
               data = exp3.avg, REML = FALSE)

model1.exp3 <- lmer(formula = loglook ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)
model1.exp3.table <- data.frame(coef(summary(model1.exp3)))

# standardized values
model1.exp3.beta <- lmer(formula = scale(loglook) ~ type * causal + (1|subj_id),
                     data = exp3.avg, REML=FALSE)

# identify and check influence of observations
# model.exp3.cooks <- exclude.cooks(model1.exp3, exp3.avg, "subj_id")

# look at contrasts within each caual condition
contrasts.exp3 <- difflsmeans(model1.exp3, test.effs="type:causal")[[1]]
names(contrasts.exp3) <- str_replace_all(names(contrasts.exp3), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp3) <- str_replace_all(names(contrasts.exp3), '-', '')
```

Experiment 3 (N=`r length(unique(exp3.avg$subj_id))`; `r length(unique(exp3.avg$subj_id))/2` per condition) attempts to replicates the findings from Experiments 1 and 2 by asking whether infants only expect causally effective reaches to be efficient, relative to the same actions that are not spatiotemporally contingent. In this experiment, pre-registered at https://osf.io/f2hvd/, we randomly assigned infants (M=`r exp3.info$mean` days, range=`r exp3.info$min`-`r exp3.info$max`, `r exp3.info$f` female) to H1 and T1, or H2 and T2, which enables us to stringently compare infants' responses to the test displays as a function of causal information. Infants again looked to the events differently depending on whether the events were causal, B=`r model1.exp3.table$Estimate[4]`, p=`r model1.exp3.table$Pr...t..[4]`, mixed effects model with fixed interaction of causality and test event. Like in Experiment 1, infants looked longer at the inefficient reach (M=`r summary.avg$look[10]`s, SD=`r summary.avg$sd[10]`) versus the efficient reach (M=`r summary.avg$look[9]`s, SD=`r summary.avg$sd[9]`) when the person’s actions were causally effective, B=`r contrasts.exp3$Estimate[6]`, p=`r contrasts.exp3$pvalue[6]`, and as in Experiment 3, infants looked equally to the inefficient (M=`r summary.avg$look[8]`s, SD=`r summary.avg$sd[8]`) and efficient (M=`r summary.avg$look[7]`s, SD=`r summary.avg$sd[7]`) reach when her actions were causally non-contingent, B=`r contrasts.exp3$Estimate[1]`, p=`r contrasts.exp3$pvalue[1]`. Together, Experiments 1-3 show that pre-reaching infants apply the principle of efficiency (Gergely & Csibra, 2003) to reaching actions that they themselves have never experienced, and that they only apply this principle to actions that appear to cause changes in the world.

## Experiments 4 and 5
```{r exp45}
# participant info
exp4.info <- ages(exp4.avg)
exp5.info <- ages(exp5.avg)

# null model
model0.exp45 <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp45.avg, REML = FALSE)

model1.exp45 <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)
model1.exp45.table <- data.frame(coef(summary(model1.exp45)))

# standardized values
model1.exp45.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp45.avg, REML=FALSE)

# identify and check influence of observations
# model1.exp45.cooks <- exclude.cooks(model1.exp45, exp45.avg, "subj_id")

# look at contrasts within each caual condition
contrasts.exp45 <- difflsmeans(model1.exp45, test.effs="type:mitten")[[1]]
names(contrasts.exp45) <- str_replace_all(names(contrasts.exp45), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp45) <- str_replace_all(names(contrasts.exp45), '-', '')

```

```{r exp5.scs}
exp5.scs <- lumi.raw.avg %>% filter(experiment == "Exp.5" | experiment == "SCS.Exp.3")


# null model
model0.exp5.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp5.scs, REML = FALSE)

model1.exp5.scs <- lmer(formula = loglook ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)
model1.exp5.scs.table <- data.frame(coef(summary(model1.exp5.scs)))

# standardized values
model1.exp5.scs.beta <- lmer(formula = scale(loglook) ~ type * mitten + (1|subj_id) + (1|experiment),
                     data = exp5.scs, REML=FALSE)

# identify and check influence of observations
model1.exp4.scs.cooks <- exclude.cooks(model1.exp5.scs, exp5.scs, "subj_id")

# look at contrasts within each caual condition
contrasts.exp5.scs <- difflsmeans(model1.exp5.scs, test.effs="type:mitten")[[1]]
names(contrasts.exp5.scs) <- str_replace_all(names(contrasts.exp5.scs), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp5.scs) <- str_replace_all(names(contrasts.exp5.scs), '-', '')

```

```{r exp4.scs}
exp4.scs <- lumi.raw.avg %>% filter(experiment == "Exp.4" | experiment == "SCS.Exp.3")

# null model
model0.exp4.scs <- lmer(formula = loglook ~ 1 + (1|subj_id) + (1|experiment),
               data = exp4.scs, REML = FALSE)

model1.exp4.scs <- lmer(formula = loglook ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)
model1.exp4.scs.table <- data.frame(coef(summary(model1.exp4.scs)))

# standardized values
model1.exp4.scs.beta <- lmer(formula = scale(loglook) ~ type * experiment + (1|subj_id) + (1|experiment),
                     data = exp4.scs, REML=FALSE)

# identify and check influence of observations
model1.exp4.scs.cooks <- exclude.cooks(model1.exp4.scs, exp4.scs, "subj_id")

# look at contrasts within each caual condition
contrasts.exp4.scs <- difflsmeans(model1.exp4.scs, test.effs="type:experiment")[[1]]
names(contrasts.exp4.scs) <- str_replace_all(names(contrasts.exp4.scs), ' ', '') # rename to fix issue with ` and - in Rmd
names(contrasts.exp4.scs) <- str_replace_all(names(contrasts.exp4.scs), '-', '')

```
Why do infants succeed here without motor training, and fail in Skerry et al. (2013)? One possibility is that pre-reaching infants struggle to understand the causal structure of reaching for and retrieving an object without the relevant motor experience. Another possibility is that pre-reaching infants do not interpret the reach of a mittened hand, one that looks different from most hands they see, as intentional without the relevant experience of observing and experiencing their own mittened hands act causally during training (cite Woodward glove?). To test for this second possibility, we ran two additional experiments. In Experiment 4 (N=`r length(unique(exp4.avg$subj_id))`), infants (M=`r exp4.info$mean` days, range=`r exp4.info$min`-`r exp4.info$max`, `r exp4.info$f` female) were habituated and tested on events very similar to those from Skerry (H4, T3), where a person reaches for and picks up an object while wearing a white mitten. In Experiment 5 (N=`r length(unique(exp4.avg$subj_id))`), infants (M=`r exp5.info$mean` days, range=`r exp5.info$min`-`r exp5.info$max`, `r exp5.info$f` female) saw almost identical videos to those from Experiment 4 except that the person reached with a bare hand (H5, T4). ^[Experiments 4 and 5 were run before Exp 2 and 3, and before our lab began to pre-register experiments. As in Experiments 2 and 3, sample sizes, analyses, and exclusionary criteria for these 2 experiments were set prior to data collection.]

We found that infants looked marginally longer at the inefficient (M=`r summary.avg$look[14]`, SD=`r summary.avg$sd[14]`) than the efficient (M=`r summary.avg$look[13]`, SD=`r summary.avg$sd[13]`) reach when a bare hand was reaching, B=`r contrasts.exp45$Estimate[1]`, p=`r contrasts.exp45$pvalue[1]/2`, and did not distinguish the inefficient (M=`r summary.avg$look[12]`, SD=`r summary.avg$sd[12]`) and efficient (M=`r summary.avg$look[11]`, SD=`r summary.avg$sd[11]`) action when a mittened hand was reaching, B=`r contrasts.exp45$Estimate[6]`, p=`r contrasts.exp45$pvalue[6]`. However, these two patterns of looking did not differ from each other, B=`r model1.exp45.table$Estimate[4]`, p=`r model1.exp45.table$Pr...t..[4]`, mixed effects model with fixed interaction between mitten and test trial, random intercept for participants.

We also compared these results against those from Skerry et al. (2013), Experiment 3, and found that the results from Experiment 5 (no mitten) differed from those in SCS Experiment 3 (mitten), B=`r model1.exp5.scs.table$Estimate[4]`, p=`r model1.exp5.scs.table$Pr...t..[4]`. However, these results are difficult to interpret, as paper (the current research vs SCS) is confounded with mitten in this analysis. Although the results from Experiment 4 (mitten) do not differ from those in SCS Experiment 3 (mitten), B=`r model1.exp4.scs.table$Estimate[4]`, p=`r model1.exp4.scs.table$Pr...t..[4]`, suggesting that the difference in paper does not uniquely account for differences across our datasets, we do not have sufficient evidence to assess the claim that manipulating whether the person wears a mitten causes infants to assess her actions differently. Thus, the effect of surface properties on infants’ action understanding is yet to be fully explored.

Looking across Experiment 1-5, we suggest that one key difference between the state change events we used in the present experiments, and the pickup events used in Skerry et al (2013), is the causal transparency of these actions: Untrained infants who do not know how to reach for and grasp objects, and thus struggle to apply a causal analysis to entrainment, may nevertheless possess the intuition that causal agents behave efficiently, an expectation they apply to state change goals.

## Analysis across present research and Skerry et al. (2013)

Across Experiments 1-5, we found that pre-reaching infants apply expectations of efficient action to agents that pursue the goal of causing a change in an object, but only weakly apply the same expectation when the person reaches for and picks up an object. To assess the unique effects of our experimental manipulations, and to compare our data directly to those from Skerry et al. (2013), we performed a meta-analysis over the 12 conditions (total N=`r length(unique(lumi.wide$subj_id))`) from these two papers. Our analytic approach allows us to assess the independent effects of a wide array of manipulations, including variations in motor training, habituation, goal, and surface properties, on infants’ expectations about efficient reaching, while controlling participant variables like age and sex, and counterbalanced variables like the order of test events. For ease of interpretation, we use average proportion looking to the inefficient action in this analysis, following Skerry et al. (2013).

```{r meta}
# set contrasts for analysis - compare effects against the grand mean
op <- options(contrasts = c("contr.sum", "contr.poly"))

# strangely, we need to flip reference levels so that ref gets compred against grand mean
lumi.wide$goal <- relevel(lumi.wide$goal, ref = "state.change")
lumi.wide$hab <- relevel(lumi.wide$hab, ref = "constrained")
lumi.wide$mitten <- relevel(lumi.wide$mitten, ref = "yes.mitten")
lumi.wide$training <- factor(lumi.wide$training, levels = c("effective.training", "ineffective.training", "no.training"))
lumi.wide$causal <- relevel(lumi.wide$causal, ref = "yes.causal")

# full exploratory model
model1.all <- lmer(formula = prop.ineff.all ~ training + hab + goal + mitten + causal + (1+first.test|experiment) + (1|ageday) + (1|sex) + (1|paper), data = lumi.wide)
model1.all.table <- gen.m(model1.all)
# address influential observations
```

***

A.
```{r meta_table, include=TRUE}
kable(model1.all.table, digits = 3)
```
B1-2.

```{r meta_figure, include=TRUE, fig.width=7}
# two ways of plotting: first, plotting model effects
plot_model(model1.all, sort.est=TRUE, show.values=TRUE, digits=3, colors = "bw",  title = "prop.ineff.all ~ training + hab + goal + mitten + causal + (1+first.test|experiment) + (1|ageday) + (1|sex) + (1|paper)")

# second, plotting model estimates for each level of categorical variable
plot(allEffects(model1.all),
     main = NA,
     ylim=c(0.39,0.61),
     cex.lab = 4,
     cex.axis = 4,
     cex = .7)
```

**Figure 3.** (A) Regression table and (B1-2) effect plots for model investigating predictors of sensitivity to action efficiency across Experiment 1-5 and all experiments from Skerry et al. (2013) (total N=`r length(unique(lumi.wide$subj_id))`). Dependent measure is proportion looking towards the inefficient reach, averaged across 3 test trials during test. Categorical predictors were coded using sum contrasts, and fixed effects from the model should therefore be interpreted with respect to the grand mean (with respect to 0, in (B). Error bars indicate 95% confidence intervals. B1 shows the effect of different manipulations relative to the grand mean. B2 shows estimates of effects at each level of all categorical predictors.

***

We found that infants’ expectations were made stronger when:  

 * the action being tested was causally contingent, B=`r model1.all.table$est[7]`, p=`r model1.all.table$p[7]` 
 * infants received effective motor training, relative to no training B=`r model1.all.table$est[2]`, p=`r model1.all.table$p[2]` 
 * they were habituated to an agent whose actions were constrained, B=`r model1.all.table$est[4]`, p=`r model1.all.table$p[4]` 
 * the person pursued a state change (vs a pickup) goal, B=`r model1.all.table$est[5]`, p=`r model1.all.table$p[5]`  

We also found that infants' expectations were not affected when:  

 * they received ineffective motor training, relative to no training, B=`r model1.all.table$est[3]`, p=`r model1.all.table$p[3]`
 * the person wore a mitten, B=`r model1.all.table$est[6]`, p=`r model1.all.table$p[6]`  

These results are consistent with our general interpretation infants expect any intentional, rational agent to reach efficiently so long as the causal mechanism of their action is clear. Either providing pre-reaching infants with motor training or presenting them with causally transparent actions helps them towards the insight that reaching is a causal, intentional action.



<!-- ## Power analyses------- -->

<!-- model.orig <- lmer(loglook ~ type + (1|subj_id), -->
<!--                    data = dplyr::filter(exp1.avg, hab == "constrained" & ageday > 90)) -->
<!-- summary(model.orig) -->

<!-- exp1.sim <- powerCurve(extend(model.orig, along="subj_id", n=400), -->
<!--                        along="subj_id", breaks = c(20, 25, 30, 35, 40), alpha = .05, seed = 123) -->
<!-- plot(exp1.sim) -->
<!-- print(exp1.sim) -->


